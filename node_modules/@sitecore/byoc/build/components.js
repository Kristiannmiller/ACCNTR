var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { getDatasource, registerDatasource } from './datasources.js';
import { getSchemaProperties, parseValue, transformSchema, transformUiSchema } from './schema.js';
import { objectKeysToKebabCase, toKebabCase } from './utils.js';
export function normalizeOptions(options, component, defaults) {
    /**
     * Usually property schema *is* the options, and ui schema is in `options.ui` property. This function normalizes schemas,
     * as stores them as `uiSchema` and `schema` properties respectively. The registerComponent() call can be made with previously
     * normalized properties (e.g. in parent frame), so it has to supports those as well.
     */
    const { thumbnail = 'https://feaasstatic.blob.core.windows.net/assets/thumbnails/byoc.svg', name, id = options.name, group = null, ui, isHidden = false, datasourceIds = [], links = {}, meta = {}, uiSchema: explicitUISchema, schema: explicitSchema } = options, schemaOptions = __rest(options, ["thumbnail", "name", "id", "group", "ui", "isHidden", "datasourceIds", "links", "meta", "uiSchema", "schema"]);
    const schemaBase = explicitSchema || schemaOptions || {};
    const useSchemaBase = explicitUISchema || ui || {};
    const schema = transformSchema(Object.assign(Object.assign({ description: 'External component' }, schemaBase), { type: 'object' }), defaults);
    const uiSchema = transformUiSchema(useSchemaBase, schema.properties || {});
    return {
        component: component || (() => null),
        name,
        schema,
        uiSchema,
        thumbnail,
        group: group || 'Default collection',
        isHidden,
        id,
        datasourceIds,
        links,
        meta,
        title: (schema === null || schema === void 0 ? void 0 : schema.title) || (schemaOptions === null || schemaOptions === void 0 ? void 0 : schemaOptions.title) || name
    };
}
var registrationCallback;
// Shim in case it's required in node.js environment
export const WebComponent = (typeof HTMLElement != 'undefined'
    ? HTMLElement
    : // @ts-ignore
        typeof windowJSDOM != 'undefined'
            ? // @ts-ignore
                windowJSDOM.HTMLElement
            : class {
                setAttribute() { }
            });
// Store registered components in a global variable BYOCComponents for external access
// On the clientside the component registry is shared via global variable, on server it doesnt to avoid breaking next.js
export const registered = typeof window != 'undefined' ? (window.BYOCComponents || (window.BYOCComponents = {})) : {};
/**
 * Register React component to be renderable as Sitecore component (in Components and Pages). Properties are defined as
 * {@link https://json-schema.org JSON Schema}, from which a configuration form will be produced using
 * {@link https://rjsf-team.github.io/react-jsonschema-form/ RJSF library}. The library allows passing a
 * {@link https://rjsf-team.github.io/react-jsonschema-form/docs/api-reference/uiSchema UI Schema} that allows tight
 * customization of form widgets, styles and behavior.
 *
 * Schema properties supports `default` option which provides a fallback value. Alternatively default properties can be
 * passed as plain javascript object as third argument to `registerComponent` call.
 *
 * It is possible to generate same component and schema with different defaults, as separate components by altering the
 * `id` property. This is used for to expand generic component like Form into different specific Form instances.
 *
 * @param {React.ComponentType}      component                     React component that will be rendered.
 * @param {string}                   options.title                 Component name as presented to the user.
 * @param {JSONSchema['properties']} options.properties            Object of properties.
 * @param {JSONSchema['type']}       options.properties[].type     JSON Schema type of a property.
 * @param {string}                   [options.properties[].title]  Optional title displayed to the user.
 * @param {string}                   [options.group]               Optional Image to be displayed in the UI.
 * @param {string}                   [options.thumbnail]           Optional title displayed to the user.
 * @param {string}                   [options.isHidden]            Optionally hide from the UI.
 * @param {UISchema}                 [options.ui]                  Optional component groupping.
 * @param {string[]}                 [options.datasourceIds]       List of datasource id component requires.
 * @see https://rjsf-team.github.io/react-jsonschema-form/docs/api-reference/uiSchema
 * @see https://json-schema.org
 * @example
 *
 *   FEAAS.External.registerComponent(
 *     MyComponent,
 *     {
 *       // Name of a component as it will be used internally
 *       name: 'MyComponent',
 *       // Title of a component as it will be presented to the user
 *       title: 'My Component',
 *       // Optional: Thumbnail image for component to be displayed in UI
 *       thumbnail: 'http://examaple.com/component.jpg',
 *       // Optional: Group components in the UI
 *       group: 'Assorted components',
 *       // Definitions of three configurable properties that MyComponent accepts
 *       properties: {
 *         // Color is a string, but only Red/Green/Blue are allowed
 *         color: { type: 'string', enum: ['red', 'green', 'blue'] },
 *         // Text is a property labelled as "Text summary"
 *         text: { type: 'string', title: 'Text summary' },
 *         // Count is a number with 1 as default value
 *         count: { type: 'number', default: 1 }
 *       },
 *       // Optional UI schema customization
 *       ui: {
 *         // Present color choices as radio buttons
 *         color: { 'ui:widget': 'radio' },
 *         // Text is a textarea with 5 rows
 *         text: { 'ui:widget': 'textarea', 'ui:options': { rows: 5 } },
 *         // Count is a number field with spinner button
 *         count: { 'ui:widget': 'updown' }
 *       },
 *       // Color and text area required properties
 *       required: ['color', 'text']
 *     },
 *     { text: 'Default text' }
 *   )
 *
 */
export function registerComponent(component, options, defaults = {}) {
    if (!(options === null || options === void 0 ? void 0 : options.name))
        throw new Error('Could not register external component. Please make sure you provide a name in the options' +
            JSON.stringify(options));
    const normalizedOptions = normalizeOptions(options, component, defaults);
    registered[normalizedOptions.id] = normalizedOptions;
    if (isWebComponent(component)) {
        BYOCRegistration.register('byoc-' + toKebabCase(options.name), undefined, component);
    }
    setRegistrationCallback();
}
export function isWebComponent(object) {
    return object && 'prototype' in object && 'setAttribute' in object.prototype;
}
/** Transform properties to proper types and merge them with default values */
export function getComponentProperties(id, props = {}) {
    var _a;
    const schema = (_a = getComponent(id)) === null || _a === void 0 ? void 0 : _a.schema;
    return schema ? getSchemaProperties(schema, props) : props;
}
export function getComponentConfigurablePropertyNames(id) {
    const definition = getComponent(id);
    return Object.keys((definition === null || definition === void 0 ? void 0 : definition.schema.properties) || {}).filter((prop) => {
        var _a, _b;
        return ((_b = (_a = definition === null || definition === void 0 ? void 0 : definition.uiSchema) === null || _a === void 0 ? void 0 : _a[prop]) === null || _b === void 0 ? void 0 : _b['ui:widget']) != 'hidden';
    });
}
/**
 * Resolve a component by its id in one of two formats:
 * - Simple id like `ComponentName` returns the registered component
 * - Complex id like `ComponentName?prop=value` returns a combination of:
 *   - `ComponentName` component if registered
 *   - `ComponentName?prop=value` component if registered
 *   - Default values provided in query string
 *
 * The latter approach allows registering a generic component under simple name, and its overloads
 * which will be presented as individual components to the user.
 */
export function getComponent(id) {
    if (typeof id != 'string') {
        if (id && 'schema' in id)
            return id;
        throw new Error(`Component name should be a string, got ${typeof id}`);
    }
    const [name, query] = id.split('?');
    var base = registered[name];
    // Deal with query string
    if (query) {
        // if component is registered with query string, merge two component definitions
        const overload = registered[id];
        if (!overload && !base)
            return null;
        if (overload)
            base = Object.assign(Object.assign(Object.assign({}, base), overload), { component: overload.component || (base === null || base === void 0 ? void 0 : base.component) });
        // merge query string as default values
        query.split(/\&/g).forEach((pair) => {
            var _a, _b, _c;
            const [k, v] = pair.split('=');
            const propertyDefinition = ((_a = base.schema.properties) === null || _a === void 0 ? void 0 : _a[k]) || {
                type: 'string'
            };
            // merge in k/v pair as default value
            base = Object.assign(Object.assign({}, base), { schema: Object.assign(Object.assign({}, base.schema), { properties: Object.assign(Object.assign({}, base.schema.properties), { [k]: Object.assign(Object.assign({}, propertyDefinition), { default: parseValue(decodeURIComponent(v), propertyDefinition.type) }) }) }), uiSchema: Object.assign(Object.assign({}, base.uiSchema), { 
                    // hide preconfigured properties
                    [k]: Object.assign(Object.assign({}, base.uiSchema[k]), { 'ui:widget': (_c = (_b = base.uiSchema[k]) === null || _b === void 0 ? void 0 : _b['ui:widget']) !== null && _c !== void 0 ? _c : 'hidden' }) }) });
        });
    }
    return base;
}
/**
 * Retrieves properties for a component, including context properties component's defaults.
 *
 * @param props  - The component props.
 * @returns An object containing the attributes, properties, and merged properties.
 */
export function getMergedComponentProperties(props) {
    const { componentName, className, fallbackWrapper, fallback, suppressHydrationWarning, _dynamic, datasources } = props, givenProps = __rest(props, ["componentName", "className", "fallbackWrapper", "fallback", "suppressHydrationWarning", "_dynamic", "datasources"]);
    try {
        var parsedDatasources = typeof datasources == 'string' ? JSON.parse(datasources) : datasources;
    }
    catch (e) { }
    // find first datasources with object data, use it as a source of properties
    const dataProperties = Object.values(parsedDatasources || {}).find((v) => v && !Array.isArray(v) && Object.keys(v).length > 0);
    const properties = Object.assign(Object.assign(Object.assign({}, dataProperties), getComponentProperties(componentName, Object.assign(Object.assign({}, dataProperties), givenProps))), (parsedDatasources ? { datasources: parsedDatasources } : {}));
    const attributes = Object.assign(Object.assign({ 'data-external-id': componentName }, objectKeysToKebabCase(properties)), { suppressHydrationWarning: true, class: className });
    serializedContextProperties.forEach((key) => {
        Object.assign(attributes, { [toKebabCase(key)]: contextProperties[key] });
    });
    // serialize json properties
    Object.keys(attributes).forEach((key) => {
        const value = attributes[key];
        if (value && typeof value == 'object' && key != 'class' && key != 'children') {
            try {
                Object.assign(attributes, { [key]: JSON.stringify(value) });
            }
            catch (e) {
                delete attributes[key];
            }
        }
        if (typeof value == 'function' || value == null) {
            delete attributes[key];
        }
    });
    return {
        /** HTML attributes in kebab case, including strings and explicitly passed objects in json format */
        attributes,
        /** React properties combined with datasources */
        properties,
        /** React properties combined with datasources and context properties */
        merged: Object.assign(Object.assign({}, contextProperties), properties)
    };
}
export function setRegistrationCallback() {
    clearTimeout(registrationCallback);
    if (typeof window !== 'undefined' && window.parent !== window) {
        registrationCallback = setTimeout(() => {
            var _a;
            // send components from iframe to parent window
            (_a = window.parent) === null || _a === void 0 ? void 0 : _a.postMessage(JSON.stringify({
                action: 'register-components',
                data: Object.values(registered)
            }), '*');
        }, 30);
    }
}
setRegistrationCallback();
// Register schemas passed as <byoc-registration components=... />
// It extends the web component in case it already was registered by different name
export class BYOCRegistration extends WebComponent {
    connectedCallback() {
        try {
            ;
            JSON.parse(String(this.getAttribute('components'))).forEach((component) => {
                if (!getComponent(component.id))
                    registerComponent(null, component);
            });
            JSON.parse(String(this.getAttribute('datasources'))).forEach((datasource) => {
                if (!getDatasource(datasource.id))
                    registerDatasource((settings) => settings, datasource);
            });
        }
        catch (e) { }
    }
    static register(tagName, win, component = this) {
        if (win == null)
            win = typeof window != 'undefined' ? window : undefined;
        if (win && !win.customElements.get(tagName)) {
            win.customElements.define(tagName, class extends component {
            });
        }
    }
}
export var contextProperties = {};
export function setContextProperties(props) {
    contextProperties = props;
}
export const serializedContextProperties = ['sitecoreEdgeUrl', 'sitecoreEdgeContextId'];
BYOCRegistration.register('byoc-registration');
//# sourceMappingURL=components.js.map