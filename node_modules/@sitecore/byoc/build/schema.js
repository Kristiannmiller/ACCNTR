import { toCamelCase, toKebabCase } from './utils.js';
import { BYOCDataTypes } from './datatypes.js';
/**
 * Iterate JSON schema including nested constructs like oneOf, allOf, if, then, etc. creating a copy in process.
 *  */
export function traverseSchema(schema, callback) {
    var traversed = {};
    for (var property in schema) {
        const value = schema[property];
        if (value && typeof value === 'object') {
            if (Array.isArray(value)) {
                traversed[property] = value.map((item) => typeof item === 'object' && item ? traverseSchema(item, callback) : item);
            }
            else {
                traversed[property] = traverseSchema(callback(value), callback);
            }
        }
        else {
            traversed[property] = schema[property];
        }
    }
    return traversed;
}
/**
 * Normalizes schema and assigns default values. It will traverse schema to normalize nested constructs.
 */
export function transformSchema(schema, defaults = {}) {
    schema = transformSchemaObject(Object.assign({ 
        /** 1. Assign schema type unless given */
        type: 'object', 
        /** 2. Ensure that properties is not null */
        properties: {}, required: [] }, schema));
    // Iterate nested constructs, without passing the defaults object
    return traverseSchema(schema, (construct) => construct.properties ? transformSchemaObject(construct, defaults) : construct);
}
/**
 * Normalizes schema and assigns default values
 */
export function transformSchemaObject(schema, defaults = {}) {
    var _a;
    const transformed = Object.assign({}, schema);
    if (transformed.properties) {
        transformed.required = ((_a = schema.required) === null || _a === void 0 ? void 0 : _a.slice()) || [];
        transformed.properties = Object.keys(transformed.properties).reduce((acc, key) => {
            var _a;
            const given = transformed.properties[key];
            const custom = (_a = BYOCDataTypes[given === null || given === void 0 ? void 0 : given.type]) === null || _a === void 0 ? void 0 : _a.call(BYOCDataTypes, given);
            const property = Object.assign(Object.assign(Object.assign({}, custom), given), { type: (custom === null || custom === void 0 ? void 0 : custom.type) || given.type, 
                /** 3. Assign default value from the explicit defaults object*/
                default: defaults.hasOwnProperty(key) ? defaults[key] : given.default, 
                /** 4. Generate fallback title */
                title: given.title ||
                    toKebabCase(key)
                        .split('-')
                        .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ') });
            if ((given === null || given === void 0 ? void 0 : given.properties) || (custom === null || custom === void 0 ? void 0 : custom.properties)) {
                property.properties = Object.assign({}, ((custom === null || custom === void 0 ? void 0 : custom.properties) || (given === null || given === void 0 ? void 0 : given.properties)));
                // Auto-merge property definitions if their names match. Will bail out when expanding nested objects like Item and List
                Object.keys((custom === null || custom === void 0 ? void 0 : custom.properties) || {}).forEach((subKey) => {
                    var _a, _b;
                    property.properties[subKey] = Object.assign(Object.assign({}, (_a = custom === null || custom === void 0 ? void 0 : custom.properties) === null || _a === void 0 ? void 0 : _a[subKey]), (_b = given === null || given === void 0 ? void 0 : given.properties) === null || _b === void 0 ? void 0 : _b[subKey]);
                });
            }
            if ((given === null || given === void 0 ? void 0 : given.items) || (custom === null || custom === void 0 ? void 0 : custom.items)) {
                property.items = (custom === null || custom === void 0 ? void 0 : custom.items) || (given === null || given === void 0 ? void 0 : given.items);
            }
            if (property.default === undefined) {
                delete property.default;
            }
            if ('required' in property && typeof property.required == 'boolean') {
                if (transformed.required.indexOf(key) == -1) {
                    transformed.required.push(key);
                }
                delete property.required;
            }
            return Object.assign(acc, {
                [key]: property
            });
        }, {});
    }
    return Object.assign({ type: 'object' }, transformed);
}
/** Make UI schema assumptions to improve the ui */
export const transformUiSchema = (uiSchema, properties) => {
    var _a, _b, _c, _d;
    let transformed = Object.assign({}, uiSchema);
    for (var property in properties) {
        if (typeof properties[property] != 'object' || !properties[property]) {
            continue;
        }
        if (((_a = properties[property]) === null || _a === void 0 ? void 0 : _a.type) == 'integer' || ((_b = properties[property]) === null || _b === void 0 ? void 0 : _b.type) == 'number') {
            transformed[property] = Object.assign(Object.assign({}, transformed[property]), { 'ui:options': {
                    widget: 'updown'
                } });
        }
        if ((_c = properties[property]) === null || _c === void 0 ? void 0 : _c.ui) {
            transformed[property] = Object.assign(Object.assign({}, transformed[property]), { 'ui:options': Object.assign(Object.assign({}, (_d = transformed[property]) === null || _d === void 0 ? void 0 : _d['ui:options']), properties[property].ui) });
        }
        transformed = Object.assign(Object.assign({}, transformed), { [property]: properties[property].items
                ? { items: transformUiSchema(transformed[property], properties[property].items.properties) }
                : transformUiSchema(transformed[property], properties[property].properties || {}) });
    }
    return transformed;
};
/** Parses a property value based on its property name and type defined in the JSON properties object. */
export function parseValue(value, type) {
    switch (type) {
        case 'string':
            return value;
        case 'object':
            try {
                return typeof value == 'object' && value != null ? value : JSON.parse(value);
            }
            catch (e) {
                return null;
            }
        case 'array':
            try {
                return Array.isArray(value) ? value : JSON.parse(value);
            }
            catch (e) {
                return null;
            }
        case 'number':
            return parseFloat(value);
        case 'integer':
            return parseInt(value);
        case 'boolean':
            return value == 'true' || value == '1';
        default:
            return value;
    }
}
/** Transform properties to match the schema types of a specified component. It will parse json for objects and arrays. */
export function parseSchemaProperties(schema, props) {
    return Object.keys(props).reduce((prev, name) => {
        const value = props[name];
        const prop = toCamelCase(name);
        const definition = schema === null || schema === void 0 ? void 0 : schema.properties[prop];
        const type = definition === null || definition === void 0 ? void 0 : definition.type;
        const parsed = parseValue(value, type);
        if (parsed != null && !name.startsWith('data-attribute') && !['class', 'id', 'contenteditable'].includes(name)) {
            return Object.assign(Object.assign({}, prev), { [prop]: parsed });
        }
        else {
            return prev;
        }
    }, {});
}
/**
 * 1. Transform properties to match the schema types of a specified component. It will parse json for objects and arrays.
 * 2. Combine it with default values as defined by the schema
 */
export function getSchemaProperties(schema, props) {
    return Object.assign(Object.assign({}, getSchemaDefaults(schema)), parseSchemaProperties(schema, props));
}
/** Get properties with their default non-null values*/
export function getSchemaDefaults(schema) {
    return Object.keys(schema.properties).reduce((prev, prop) => {
        var _a, _b;
        if (((_a = schema.properties[prop]) === null || _a === void 0 ? void 0 : _a.default) != null) {
            return Object.assign(Object.assign({}, prev), { [prop]: (_b = schema.properties[prop]) === null || _b === void 0 ? void 0 : _b.default });
        }
        else {
            return prev;
        }
    }, {});
}
//# sourceMappingURL=schema.js.map