import { transformSchema } from './schema.js';
// Store registered datasources in a global variable BYOCDatasources for external access
// On the clientside the datasource registry is shared via global variable, on server it doesnt to avoid breaking next.js
export const registeredDatasources = typeof window != 'undefined' ? (window.BYOCDatasources || (window.BYOCDatasources = {})) : {};
/**
 * Registers a custom datasource with the provided function and schema.
 *
 * @param handler               - A function that returns the DataSettings settings.
 * @param options               - Options for the datasource. Includes the datasource id, schema, and other
 *                              metadata.
 * @param {string} options.id            - Unique identifier of the datasource.
 * @param {string} [options.name]        - (Optional) Internal name of a datasource. Defaults to the id.
 * @param {string} [options.sample]      - (Optional) Sample data for the datasource (alternative to schema).
 * @param {string} [options.type]        - (Optional) JSON Schema type (array or object).
 * @param {string} [options.properties]  - (Optional) JSON Schema properties definition.
 * @param {string} [options.schema]      - (Optional) Whole JSON Schema definition.
 * @returns Void.
 * @example
 *
 *   // HTTP-based datasource, described by schema
 *
 *   registerDatasource(
 *     () => ({
 *       url: 'https://api.sampleapis.com/wines/reds'
 *     }),
 *     {
 *       id: 'http-and-schema',
 *       name: 'Wines via HTTP',
 *       description: 'List of red wines fetched by HTTP, each with `wine`, `price` and `id` property',
 *       type: 'array',
 *       properties: {
 *         wine: { type: 'string' },
 *         price: { type: 'string' },
 *         id: { type: 'number' }
 *       }
 *     }
 *   )
 *
 * @example
 *
 * // When datasource is registered with ID of a datasource that exist in the library, it can adjust the data settings of the
 * original request.
 *
 * registerDatasource(
 *   // settings will contain DataSettings as specified via UI in Components app
 *   (settings) => ({
 *     ...settings,
 *     params: {
 *       // add ?page=2 parameter to the original URL
 *       ...settings.params,
 *       page: 2
 *     },
 *     headers: {
 *       // add Authorization header in addition to original headers
 *       ...settings.headers,
 *       Authorization: 'Bearer token'
 *     }
 *   }),
 *   {
 *     // ID of a datasource as created in UI (can be visible in the address bar URL) to be extended
 *     // No other options are specified in this case.
 *     id: 'aBcDaaa23a'
 *   }
 * )
 *
 * @example
 *
 *   import { promises as fs } from 'fs'
 *   // Async handlers supposed to return data itself instead of DataSettings
 *
 *   registerDatasource(
 *     async () => {
 *       return JSON.parse(await fs.readFile('wines.json', 'utf-8'))
 *     },
 *     {
 *       id: 'file-and-sample',
 *       name: 'Wines from JSON file',
 *       description: 'JSON file read and parsed from file (no HTTP request is made), with sample data',
 *       sample: [
 *         { wine: 'Emporda 2012', id: 1, price: '$250' },
 *         { wine: 'PÃªra-Manca Tinto 1990', id: 2, price: '$312' }
 *       ]
 *     }
 *   )
 *
 */
export function registerDatasource(handler, options) {
    if (typeof handler !== 'function') {
        throw new Error(`The first argument of registerDatasource must be a function returning DataSettings or Promise of data`);
    }
    if (!options.id) {
        throw new Error(`Missing 'id' property in input`);
    }
    const idRegex = /^[a-zA-Z0-9-_]+$/;
    if (!idRegex.test(options.id)) {
        throw new Error(`Invalid 'id' property in input. 'id' should only contain alphanumeric characters, hyphens, and underscores.`);
    }
    //if (getDatasource(options.id)?.handler != null) {
    //  throw new Error(`Datasource with id ${options.id} already registered`)
    //}
    registeredDatasources[options.id] = Object.assign(Object.assign({}, normalizeDatasourceOptions(options)), { handler });
    setRegistrationCallback();
}
/**
 * Returns the registered datasource with the provided id.
 *
 * @param id  - The id of the registered datasource.
 * @returns The registered datasource.
 */
export function getDatasource(id) {
    return registeredDatasources[id];
}
/**
 * Normalizes the datasource options. If the schema is not provided, it will be derived from the properties.
 *
 * @param datasourceOptions  - The datasource options.
 * @returns The normalized datasource options.
 */
function normalizeDatasourceOptions(datasourceOptions) {
    const { id, name, title, properties, sample, schema, description = null, type = 'object' } = datasourceOptions;
    return {
        id,
        description,
        sample,
        name: name || title || id,
        handler: ((settings) => settings),
        schema: schema || properties
            ? transformSchema(Object.assign(Object.assign({}, (schema || { properties, type })), { title: (schema === null || schema === void 0 ? void 0 : schema.title) || title || name }))
            : undefined
    };
}
var registrationCallback;
function setRegistrationCallback() {
    clearTimeout(registrationCallback);
    if (typeof window !== 'undefined' && window.parent !== window) {
        registrationCallback = setTimeout(() => {
            var _a;
            // send datasources from iframe to parent window
            (_a = window.parent) === null || _a === void 0 ? void 0 : _a.postMessage(JSON.stringify({
                action: 'register-datasources',
                data: Object.values(registeredDatasources)
            }), '*');
        }, 30);
    }
}
setRegistrationCallback();
/**
 * For given datasource id and original settings, either returns adjusted settings or a promise of data.
 */
export function customizeDataSettings(id, settings) {
    const datasource = registeredDatasources[id];
    if (datasource === null || datasource === void 0 ? void 0 : datasource.handler) {
        return datasource.handler(settings);
    }
    return settings;
}
//# sourceMappingURL=datasources.js.map