var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { getComponent, getMergedComponentProperties, isWebComponent, registeredDatasources, registered, toKebabCase } from '@sitecore/byoc';
import React from 'react';
export * from '@sitecore/byoc';
var NextClientsideRenderer = null;
var NextDynamicFunction = null;
/**
 * A special case of Component designed for Next.js.
 * It uses `next/dynamic` to control rendering on the client, server, or both.
 *
 * @param {ComponentProps} props  - The properties for the component.
 * @returns {JSX.Element} The JSX element representing the component.
 */
export function NextComponent(props) {
    var _a;
    // See if component is registered in current context
    const { componentName, clientFallback } = props, attributes = __rest(props, ["componentName", "clientFallback"]);
    const Component = (_a = getComponent(componentName)) === null || _a === void 0 ? void 0 : _a.component;
    // Render component as is on the server
    const Regular = React.useMemo(() => React.createElement(RegularComponent, Object.assign({}, attributes, { componentName: componentName })), []);
    // maintain identity of wrapped component
    const External = React.useMemo(() => NextDynamicFunction(() => Promise.resolve(NextClientsideRenderer), {
        ssr: false,
        // Show server-rendered component during page load
        loading: () => Regular
    }), []);
    // remove functions from props to avoid them to be passed from server to client which is illegal
    var sanitizedAttributes = typeof window == 'undefined' ? JSON.parse(JSON.stringify(attributes)) : attributes;
    return (React.createElement(External, Object.assign({}, sanitizedAttributes, { componentName: componentName, fallbackWrapper: !Component, fallback: Component
            ? // If there's no client component, keep the server-rendered component displayed
                Regular
            : // wrap clientFallback into a dynamic() call to make it render clientside hydration
                clientFallback
                    ? React.createElement(NextDynamicFunction(() => Promise.resolve(() => clientFallback), { ssr: false }))
                    : props.fallback })));
}
/**
 * Enables Next.js client/server rendering options for registered components.
 * The `component` argument should be a function exported from a file with a `use client` directive.
 *
 * @param {any} dynamic    - The Next dynamic function.
 * @param {any} component  - The component function.
 * @returns {any} Augmented bundle.
 */
export function enableNextClientsideComponents(dynamic, component) {
    NextDynamicFunction = dynamic;
    NextClientsideRenderer = component;
    return component;
}
/**
 * Renders a registered external component in a React tree. If enableNextClientsideComponents was called previously,
 * the component is rendered using NextComponentÂ codepath, which allows rendering separate component on client and
 * server.
 *
 * @param {ComponentProps} props  - The properties for the component.
 * @returns {JSX.Element} The JSX element representing the component.
 */
export function Component(props) {
    if (Object.keys(props).length == 0) {
        return React.createElement(React.Fragment, null);
    }
    // _dynamic property ensures the component does not endlessly loop in pre-app-router setup
    if (NextDynamicFunction && !props._dynamic) {
        return NextComponent(Object.assign({ _dynamic: true }, props));
    }
    return RegularComponent(props);
}
/**
 * Pass list of server side component registrations to clients, and embed clientside components to the page.
 */
export function Bundle() {
    return (React.createElement(React.Fragment, null,
        React.createElement("byoc-registration", { components: JSON.stringify(Object.values(registered)), datasources: JSON.stringify(Object.values(registeredDatasources)), suppressHydrationWarning: true }),
        React.createElement(NextClientsideRenderer, null)));
}
/**
 * A wrapper over External component that accepts a fallback for rendering in case of a missing component.
 * It accepts properties in camelcase format and ensures no hydration errors on the client-side.
 *
 * @param {ComponentProps} props  - The properties for the component.
 * @returns {JSX.Element} The JSX element representing the component.
 */
export function RegularComponent(props) {
    const { componentName, fallback, fallbackWrapper } = props;
    const definition = getComponent(componentName);
    const Component = definition === null || definition === void 0 ? void 0 : definition.component;
    const { attributes, properties, merged } = getMergedComponentProperties(props);
    if ((!Component && fallback) || !componentName) {
        if (fallbackWrapper === false)
            return React.createElement(React.Fragment, null, fallback);
        return (React.createElement("feaas-external", Object.assign({}, attributes, { hydrate: 'false' }), fallback));
    }
    if (definition && Component && isWebComponent(Component)) {
        const webComponentName = 'byoc-' + toKebabCase(definition.id);
        return React.createElement(webComponentName, Object.assign(Object.assign({}, attributes), { ref: (el) => {
                var _a;
                if (el && typeof window != 'undefined') {
                    // web components can define sitecoreContextCallback defined that recieves props directly
                    (_a = window.customElements) === null || _a === void 0 ? void 0 : _a.whenDefined(webComponentName).then(() => {
                        var _a;
                        (_a = el.sitecoreContextCallback) === null || _a === void 0 ? void 0 : _a.call(el, Object.assign({}, merged));
                    });
                }
            } }));
    }
    return (React.createElement(React.Fragment, null,
        React.createElement("feaas-external", Object.assign({}, attributes, { hydrate: 'false' }), Component == null ? null : React.createElement(Component, Object.assign({}, merged)))));
}
//# sourceMappingURL=react.js.map