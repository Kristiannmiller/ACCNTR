import type { UiSchema } from '@rjsf/utils';
/** Simplified JSON schema for improved suggestions */
import { JSONSchema7, JSONSchema7TypeName } from 'json-schema';
export type JSONSchema7GenericKeys = Exclude<keyof JSONSchema7, 'items' | 'additionalItems' | 'properties' | 'additionalProperties' | 'patternProperties' | 'dependencies' | 'required' | 'minProperties' | 'maxProperties' | 'minItems' | 'maxItems' | 'uniqueItems' | 'minLength' | 'maxLength' | 'pattern' | 'format' | 'minimum' | 'maximum' | 'multipleOf' | 'exclusiveMinimum' | 'exclusiveMaximum' | 'propertyNames' | 'contains' | '$schema' | 'definitions' | '$defs' | '$comment' | 'const' | 'examples' | 'readOnly' | 'writeOnly' | 'contentMediaType' | 'contentEncoding' | 'if' | 'then' | 'else' | 'allOf' | 'anyOf' | 'oneOf' | 'not' | '$ref' | '$id'>;
/** Schema for common properties. */
export interface BaseSchema<T extends JSONSchema7TypeName> extends Pick<JSONSchema7, JSONSchema7GenericKeys> {
    /** The type of data. */
    type: T;
    [key: string]: any;
}
/** Schema for string type properties. */
export interface StringSchema extends BaseSchema<'string'> {
    /** Minimum length of the string. */
    minLength?: number;
    /** Maximum length of the string. */
    maxLength?: number;
    /** A regex pattern the string should match. */
    pattern?: string;
    /** Named format the string should adhere to. */
    format?: string;
}
/** Schema for number type properties. */
export interface NumberSchema extends BaseSchema<'number' | 'integer'> {
    /** Minimum value of the number. */
    minimum?: number;
    /** Maximum value of the number. */
    maximum?: number;
    /** The number should be a multiple of this value. */
    multipleOf?: number;
}
/** Schema for object type properties. */
export interface ObjectSchema extends BaseSchema<'object'> {
    /** Properties of the object. */
    properties?: Record<string, JSONSchema>;
    /** Additional properties not covered by 'properties'. */
    additionalProperties?: JSONSchema | boolean;
    /** Array of required properties. */
    required?: string[];
    /** Minimum number of properties. */
    minProperties?: number;
    /** Maximum number of properties. */
    maxProperties?: number;
    /** Properties matching the patterns. */
    patternProperties?: Record<string, JSONSchema>;
    /** Property dependencies. */
    dependencies?: Record<string, JSONSchema | string[]>;
}
/** Schema for array type properties. */
export interface ArraySchema extends BaseSchema<'array'> {
    /** Items in the array. */
    items?: JSONSchema | JSONSchema[];
    /** Additional items not covered by 'items'. */
    additionalItems?: JSONSchema | boolean;
    /** Minimum number of items. */
    minItems?: number;
    /** Maximum number of items. */
    maxItems?: number;
    /** All items should be unique. */
    uniqueItems?: boolean;
}
/** Schema for boolean type properties. */
export interface BooleanSchema extends BaseSchema<'boolean'> {
}
/** Schema for null type properties. */
export interface NullSchema extends BaseSchema<'null'> {
}
/** Definition of JSON Schema type. */
export type JSONSchema = StringSchema | NumberSchema | ObjectSchema | ArraySchema | BooleanSchema | NullSchema;
/**
 * JSON Schema is limited in describing how a given data type should be rendered as a form input component. That's why
 * this library introduces the concept of uiSchema.
 *
 * A UI schema is basically an object literal providing information on how the form should be rendered, while the JSON
 * schema tells what.
 *
 * @see https://rjsf-team.github.io/react-jsonschema-form/docs/api-reference/uiSchema
 * @example
 *
 * {
 *       // Present color choices as radio buttons
 *       color: { 'ui:widget': 'radio' },
 *       // Text is a textarea with 5 rows
 *       text: { 'ui:widget': 'textarea', 'ui:options': { rows: 5 } },
 *       // Count is a number field with spinner button
 *       count: { 'ui:widget': 'updown' }
 *     },
 *
 */
export type UISchema = UiSchema;
export type JSONSchemaConstruct = Partial<ArraySchema | ObjectSchema>;
/**
 * Iterate JSON schema including nested constructs like oneOf, allOf, if, then, etc. creating a copy in process.
 *  */
export declare function traverseSchema(schema: JSONSchemaConstruct, callback: (value: JSONSchemaConstruct) => JSONSchemaConstruct): JSONSchemaConstruct;
/**
 * Normalizes schema and assigns default values. It will traverse schema to normalize nested constructs.
 */
export declare function transformSchema(schema: Partial<ObjectSchema | ArraySchema>, defaults?: Record<string, any>): JSONSchemaConstruct;
/**
 * Normalizes schema and assigns default values
 */
export declare function transformSchemaObject(schema: Partial<ObjectSchema | ArraySchema>, defaults?: Record<string, any>): ObjectSchema | ArraySchema;
/** Make UI schema assumptions to improve the ui */
export declare const transformUiSchema: (uiSchema: UISchema, properties: Record<string, any>) => UISchema;
/** Parses a property value based on its property name and type defined in the JSON properties object. */
export declare function parseValue(value: any, type: JSONSchema['type']): any;
/** Transform properties to match the schema types of a specified component. It will parse json for objects and arrays. */
export declare function parseSchemaProperties(schema: JSONSchema, props: Record<string, string>): any;
/**
 * 1. Transform properties to match the schema types of a specified component. It will parse json for objects and arrays.
 * 2. Combine it with default values as defined by the schema
 */
export declare function getSchemaProperties(schema: JSONSchema, props: Record<string, string>): any;
/** Get properties with their default non-null values*/
export declare function getSchemaDefaults(schema: JSONSchema): any;
//# sourceMappingURL=schema.d.ts.map