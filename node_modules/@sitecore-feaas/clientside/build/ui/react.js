import * as BYOC from '@sitecore/byoc/react';
import React from 'react';
import { parseHTMLContent, renderHTMLContent } from '../dom/html.js';
import { DataSettings } from '../utils/settings.js';
import { fetchComponent, getComponentURL, getStylesheetSource, getStylesheetURL, parseComponentSource, parseStylesheetSource } from './index.js';
export * from '../headless.js';
export { External, FEAASExternalPropsObject, linkComponents } from './FEAASExternal.js';
export * from './index.js';
export { renderHTMLContent };
var ReactElementComponents = {};
/**
 * Set custom implementation for a HTML tag name. Useful for Next.js Image component, handling image optimization.
 *
 * @param Component
 */
export function setElementImplementation(tagName, Component) {
    ReactElementComponents[tagName] = Component;
}
export function normalizeFetchAttribute(fetch) {
    if (fetch == null || fetch === true) {
        return ['template', 'stylesheet', 'data'];
    }
    return [].concat(fetch || []);
}
/**
 * A component to include a stylesheet using a <link> tag. Placing one in the HEAD ensures that there will be no flash
 * of unstyled content.
 *
 * @param {FEAASCDNStylesheetParams | FEAASCDNStylesheetSource} props  - The properties for including the stylesheet.
 * @returns {JSX.Element} The <link> element for the stylesheet.
 */
export const FEAASReactStylesheet = (props) => {
    if ('src' in props) {
        props = parseStylesheetSource(props.src);
    }
    return React.createElement("link", { rel: 'stylesheet', href: getStylesheetSource(props) });
};
/**
 * An asynchronous wrapper over FEAAS.Component for use in React, especially suited for Next.js.
 * This component fetches HTML and data asynchronously for server-side rendering with data mapping.
 *
 * @param {FEAASReactComponentProps} props  - The properties for the component.
 * @returns {Promise<JSX.Element>} The JSX element representing the component.
 */
export const FEAASReactServerComponent = async ({ data, fetch, ...props }) => {
    const fetchedData = await DataSettings.fetch(data || {});
    fetch = normalizeFetchAttribute(fetch !== null && fetch !== void 0 ? fetch : ['stylesheet']);
    const p = { ...props };
    if (('src' in props || 'component' in props) && (props === null || props === void 0 ? void 0 : props.template) == null) {
        const response = await fetchComponent(props);
        p.template = response.template;
        p.lastModified = response.lastModified;
    }
    else if ((props === null || props === void 0 ? void 0 : props.template) == null && !fetch.includes('template')) {
        fetch.push('template');
    }
    return FEAASReactComponent({
        ...p,
        data,
        fetch,
        fetchedData
    });
};
/**
 * A wrapper over FEAAS.Component for use in React. It converts a passed template HTML into React,
 * allowing external components in the render tree. Data can be provided in JSON format.
 *
 * @param {FEAASReactComponentProps} props  - The properties for the component.
 * @returns {JSX.Element} The JSX element representing the component.
 */
export function FEAASReactComponent({ data, lastModified, fetchedData, renderNode, ...props }) {
    let preload = null;
    let children;
    if ('template' in props && props.template) {
        children = parseHTMLContent(props.template, fetchedData || data || {}).map((node, index) => HTMLNodeToReact(node, (node, attributes) => {
            // invoke customization of HTML node rendering
            if (renderNode) {
                const override = renderNode === null || renderNode === void 0 ? void 0 : renderNode(node, attributes);
                if (override != null && 'type' in override) {
                    return [override.type, override.props];
                }
                attributes = {
                    ...attributes,
                    ...override
                };
            }
            // Override rendering of html tag if user provided
            if (ReactElementComponents[node.localName]) {
                return [ReactElementComponents[node.localName], attributes];
            }
            if (node.localName == 'feaas-external') {
                const camelized = {};
                for (var prop in attributes) {
                    const key = prop == 'data-external-id' ? 'componentName' : BYOC.toCamelCase(prop);
                    camelized[key] = attributes[prop];
                }
                return [BYOC.Component, camelized];
            }
        }, index));
    }
    if ('src' in props) {
        props = { ...parseComponentSource(props.src), ...props };
    }
    const fetch = normalizeFetchAttribute(props.fetch);
    const embeddedData = fetch.includes('data') ? data : fetch.includes('template') ? fetchedData || data : null;
    return (React.createElement(React.Fragment, null,
        'preload' in props && preload === true && 'src' in props && (React.createElement(React.Fragment, null,
            React.createElement("link", { rel: 'preload', as: 'fetch', href: getComponentURL(props.src), crossOrigin: 'anonymous' }),
            React.createElement("link", { rel: 'preload', as: 'style', href: getStylesheetURL(props.src), crossOrigin: 'anonymous' }))),
        React.createElement("feaas-component", { class: '-feaas', ...props, "last-modified": lastModified ? String(lastModified) : null, fetch: props.fetch == null ? props.fetch : [].concat(props.fetch).join(' '), suppressHydrationWarning: true, template: null, data: typeof embeddedData == 'string' ? embeddedData : embeddedData ? JSON.stringify(embeddedData) : null }, children)));
}
/**
 * Converts an HTMLNode into a React tree, ensuring proper context access for external components.
 *
 * @param {HTMLNode} node        - The HTML node to be converted.
 * @param {any}      [callback]  - Callback to customize turning of HTML node into react tree.
 * @param {any}      [key]       - The key for the React element.
 * @returns {React.ReactNode} The resulting React node.
 */
export function HTMLNodeToReact(node, callback, key) {
    var _a;
    if (node.nodeType === 3) {
        return node.textContent;
    }
    const children = Array.from(node.childNodes).map((child, index) => HTMLNodeToReact(child, callback, index));
    const attributes = {};
    for (let i = 0; i < node.attributes.length; i++) {
        const { name, value } = node.attributes[i];
        if (name == 'style') {
            attributes[name] = String(value || '')
                .trim()
                .split(/\s*;\s*/)
                .reduce((object, pair) => {
                const [k, v] = pair.split(':');
                return {
                    ...object,
                    [BYOC.toCamelCase(k)]: v
                };
            }, {});
        }
        else if (name == 'class') {
            attributes.className = value;
        }
        else {
            attributes[name] = value;
        }
    }
    const reactNode = callback === null || callback === void 0 ? void 0 : callback(node, attributes);
    const reactName = (reactNode === null || reactNode === void 0 ? void 0 : reactNode[0]) || node.nodeName.toLowerCase();
    if (reactName == 'style') {
        attributes.dangerouslySetInnerHTML = { __html: children.join('\n') };
    }
    const reactAttributes = Object.assign({ key, suppressHydrationWarning: true }, (reactNode === null || reactNode === void 0 ? void 0 : reactNode[1]) || attributes);
    const reactChildren = ((_a = reactNode === null || reactNode === void 0 ? void 0 : reactNode[1]) === null || _a === void 0 ? void 0 : _a.children) || children;
    return React.createElement(reactName, reactAttributes, ['img', 'br', 'input', 'style'].includes(reactName) ? null : reactChildren);
}
export const enableNextClientsideComponents = BYOC.enableNextClientsideComponents;
export const setContextProperties = BYOC.setContextProperties;
export const ExternalComponentBundle = BYOC.Bundle;
export const ExternalComponent = BYOC.Component;
export const ReactExternalComponent = BYOC.RegularComponent;
export const NextExternalComponent = BYOC.NextComponent;
export const Component = FEAASReactComponent;
export const ServerComponent = FEAASReactServerComponent;
export const Stylesheet = FEAASReactStylesheet;
//# sourceMappingURL=react.js.map