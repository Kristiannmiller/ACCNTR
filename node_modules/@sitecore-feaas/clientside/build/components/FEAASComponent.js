import { DEFAULT_CDN_URL, fetchAndRevalidateComponent, parseComponentSource } from '../cdn.js';
import { renderDOMContent, renderDOMElement } from '../dom/rendering.js';
import { loadStylesheetAllowStale } from '../headless.js';
import { ControlledPromise } from '../utils/promise.js';
import { DataSettings } from '../utils/settings.js';
import { FEAASElement } from './FEAASElement.js';
export function FEAASComponentsProps(element) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let data;
    const src = element.getAttribute('src');
    if (src) {
        const parsed = parseComponentSource(src);
        if (!parsed)
            throw new Error(`Could not parse FEAAS Component source: ${src}`);
        var { cdn, library, component, version, revision } = parsed;
    }
    const dataValue = element.getAttribute('data');
    if (dataValue != null && dataValue != '') {
        try {
            data = typeof dataValue == 'string' ? JSON.parse(dataValue) : {};
        }
        catch (e) {
            console.error(e);
        }
    }
    const fetch = element.getAttribute('fetch');
    return {
        data: (data || {}),
        cdn: (_b = (_a = element.getContextAttribute('cdn')) !== null && _a !== void 0 ? _a : cdn) !== null && _b !== void 0 ? _b : DEFAULT_CDN_URL,
        library: (_c = element.getAttribute('library')) !== null && _c !== void 0 ? _c : library,
        component: (_d = element.getAttribute('component')) !== null && _d !== void 0 ? _d : component,
        version: (_f = (_e = element.getAttribute('version')) !== null && _e !== void 0 ? _e : version) !== null && _f !== void 0 ? _f : 'responsive',
        revision: ((_h = (_g = element.getAttribute('revision')) !== null && _g !== void 0 ? _g : revision) !== null && _h !== void 0 ? _h : 'published'),
        hostname: element.getAttribute('hostname'),
        template: element.getAttribute('template'),
        instance: element.getAttribute('instance'),
        editable: element.getAttribute('editable') != null,
        suspended: element.getAttribute('suspended') != null,
        lastModified: element.getAttribute('last-modified'),
        fetch: fetch == 'false' || (fetch == null && element.hasAttribute('fetch'))
            ? []
            : fetch == null || fetch == 'true'
                ? ['data', 'template', 'stylesheet']
                : fetch.split(/(\s+|\-)+/g).filter(Boolean)
    };
}
/**
 * - Initialization lifecycle:
 * - - `set(props)`
 * - - `scheduleRender()` - any attribute change causes render to schedule to next frame
 * - - `whenRendered.restart()` - rendering promise is reset and will resolve after render
 * - - `advance()` - called on next frame
 * - - `if (isReadyToLoad()) => boolean` - check if component has all necessary properties to load
 * - - `load() => payload` => component is loaded
 * - - `onLoad?(payload)` => invoke loaded callback for cached version of a component
 * - - `advance()` => going further in state machine
 * - - `flush()` => flushes all react changes if needed
 * - - `update()` => component-specific method (or react) to render changes to dom
 * - - `render(payload, props)` => render means react
 * - - `whenRendered.resolve()` - rendering promise is resolved after rendering
 * - - IF CACHE WAS STALE - FETCH AND RENDER AGAIN
 * - - `fetchByPassingCache()` - load up-to-date version of a component
 * - - `onLoad(newPayload) `
 * - - `advance()` => going further in state machine
 * - - `flush()` => flushes all react changes if needed
 * - - `update()` => component-specific method (or react) to render changes to dom
 * - - `render(payload, props)` => render means react
 * - - `whenRendered.resolve()` - rendering promise is resolved after rendering
 * - - `whenLoaded.resolved()` - resolved after loading of up to date component
 */
class FEAASComponent extends FEAASElement {
    setData(data) {
        this.set({ data });
    }
    getProps() {
        return FEAASComponentsProps(this);
    }
    isJSONAttribute(prop) {
        return prop == 'data';
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue)
            return;
        // force component to be refreshed
        if (name == 'library' || name == 'component' || name == 'revision' || name == 'version') {
            this.payload = undefined;
            if (this.alreadyRendered && this.connected) {
                this.needsRefresh = true;
                this.needsToFetchTemplate = true;
            }
        }
        super.attributeChangedCallback(name, oldValue, newValue);
        if (name == 'data') {
            this.needsRefresh = true;
            if (this.props.fetch.includes('data') || this.alreadyRendered || !DataSettings.hasDataSettings(this.props.data)) {
                this.fetchData();
            }
        }
    }
    // Reset readyData and perform a new fetch.
    async fetchData() {
        this.readyData = undefined;
        this.whenDataReady = this.whenDataReady.restart();
        const data = await DataSettings.fetch(this.props.data);
        const alreadyRendered = this.alreadyRendered;
        await this.whenDataReady.resolve(data);
        if (alreadyRendered) {
            this.advance();
        }
    }
    getEditor() {
        var _a;
        return (_a = document.querySelector('feaas-context')) === null || _a === void 0 ? void 0 : _a.refs.editor;
    }
    constructor() {
        super();
        this.readyData = {};
        this.whenDataReady = ControlledPromise((data) => (this.readyData = data), (e) => this.onError(e));
        this.defaultProps = {
            cdn: DEFAULT_CDN_URL,
            revision: 'published',
            version: 'responsive',
            editable: false,
            suspended: false,
            data: {}
        };
        this.onLoad = (html) => {
            this.payload = html;
            this.advance();
        };
        const data = this.getAttribute('data');
        if (!this.getAttribute('data')) {
            this.whenDataReady.resolve({});
        }
        this.addEventListener('click', () => {
            if (this.props.editable) {
                this.edit();
            }
        });
    }
    edit() {
        const editor = this.getEditor();
        if (editor === null || editor === void 0 ? void 0 : editor.setTarget(this)) {
            editor.open();
            return true;
        }
    }
    /* Check if component is a repeated clone, and return the original */
    getOriginal() {
        const scope = this.getAttribute('data-path-scope');
        if (!scope)
            return;
        for (var current = this; (current = current.previousElementSibling);) {
            if (current.getAttribute('data-path-scope') == scope) {
                var last = current;
            }
            else {
                break;
            }
        }
        return last;
    }
    isReadyToLoad() {
        return (super.isReadyToLoad() && this.props.library != null && this.props.component != null && this.props.version != null);
    }
    async load() {
        var _a;
        // defer loading to original element
        if (this.getOriginal())
            return;
        const advanceIfEverythingIsReady = () => {
            // html is not loaded
            if (this.payload == null)
                return;
            // shared stylesheet is still being loaded
            if (stylesheetPromise)
                return;
            // data is still loading
            if (!this.readyData)
                return;
            this.onLoad(this.payload);
        };
        if (this.props.fetch.includes('stylesheet')) {
            var stylesheetPromise = loadStylesheetAllowStale({ ...this.props }).then(() => {
                stylesheetPromise = null;
                advanceIfEverythingIsReady();
            });
        }
        if (this.props.fetch.includes('template') || this.needsToFetchTemplate) {
            this.needsToFetchTemplate = false;
            var templatePromise = fetchAndRevalidateComponent(this.props, (html) => {
                this.payload = html;
                this.needsRefresh = true;
                advanceIfEverythingIsReady();
            });
        }
        else {
            this.payload = (_a = this.props.template) !== null && _a !== void 0 ? _a : this.innerHTML;
        }
        return Promise.all([
            stylesheetPromise,
            this.whenDataReady.then(() => advanceIfEverythingIsReady()),
            templatePromise
        ]).then(() => this.payload);
    }
    flush() {
        if (!this.readyData)
            return;
        super.flush();
    }
    update() {
        this.alreadyRendered = true;
        // avoid unnecessary rendering if hydration was disabled
        if (!this.props.fetch.includes('data') &&
            !this.props.fetch.includes('template') &&
            this.firstElementChild &&
            !this.needsRefresh)
            return;
        if (Array.from(this.children).filter((c) => c.tagName != 'BR').length > 0 && !this.needsRefresh) {
            renderDOMElement(this, this.readyData);
        }
        else {
            this.needsRefresh = false;
            // defer rendering to original element
            if (this.getOriginal()) {
                return;
            }
            renderDOMContent(this, this.payload, this.readyData);
        }
    }
}
FEAASComponent.observedAttributes = [
    'library',
    'component',
    'version',
    'revision',
    'hostname',
    'cdn',
    'template',
    'data',
    'instance',
    'editable',
    'with-stylesheet',
    'fetch'
];
export { FEAASComponent };
FEAASComponent.register('feaas-component');
export { FEAASComponent as Component, FEAASComponentsProps as ComponentProps };
//# sourceMappingURL=FEAASComponent.js.map