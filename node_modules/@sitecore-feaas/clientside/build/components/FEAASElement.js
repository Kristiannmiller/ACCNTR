import { ControlledPromise } from '../utils/promise.js';
// Shim in case it's required in node.js environment
var WebComponent = typeof HTMLElement == 'undefined'
    ? // @ts-ignore
        typeof windowJSDOM != 'undefined'
            ? // @ts-ignore
                windowJSDOM.HTMLElement
            : class {
            }
    : HTMLElement;
/**
 * FEAASElement is a superclass for FEAAS components with optional react support.
 *
 * Initialization lifecycle:
 *
 * - `set(props)`
 * - `scheduleRender()` - any attribute change causes render to schedule to next frame
 * - `whenRendered.restart()` - rendering promise is reset and will resolve after render
 * - `advance()` - called on next frame
 * - `if (isReadyToLoad()) => boolean` - check if component has all necessary properties to load
 * - `load() => payload` => component is loaded
 * - `onLoad?(payload)` => invoke loaded callback
 * - `advance()` => going further in state machine
 * - `flush()` => flushes all react changes if needed
 * - `update()` => component-specific method (or react) to render changes to dom
 * - `render(payload, props)` => render means react
 * - `whenRendered.resolve()` - rendering promise is resolved after rendering
 * - `whenLoaded.resolved()` - resolved after loading and rendering
 */
export class FEAASElement extends WebComponent {
    /** Return attributes as parsed values */
    getProps(context) {
        return {};
    }
    constructor() {
        super();
        this.defaultProps = {};
        /** Is/was component in the dom? */
        this.connected = false;
        this.refs = {};
        this.descendants = [];
        this.whenLoaded = ControlledPromise((payload) => {
            this.payload = payload;
        });
        this.whenRendered = ControlledPromise(() => (this.initialized = true), () => this.cancelRender());
        this.addEventListener('feaasMount', this);
        this.addEventListener('feaasUnmount', this);
    }
    /** Attaches shadow root if getShadowRootOptions any settings, or uses element itself */
    getRoot() {
        return this;
    }
    /** Attribute changes trigger props parsing and schedules re-rendering */
    attributeChangedCallback(name, oldValue, newValue) {
        this.set();
    }
    /** Components parses its attributes when connected, and schedules rendeirng */
    connectedCallback() {
        this.mount();
    }
    disconnectedCallback() {
        this.unmount();
    }
    /**
     * Web components are initialized depth-first, making child elements render before its parents. This could here
     * attempts to avoid this and inverts the initialization logic, so that children are initialized in the context of its
     * already-initialized parents.
     *
     * FEAAS components dispatch `feaasMount` event that allows components to store references to each other. In addition
     * it allows external scripts to listen for initialization of FEAAS components
     */
    mount() {
        try {
            const parent = this.getParent();
            // Allow parent component to initialize first
            if (parent && !parent.connected)
                return;
            if (this.connected)
                return;
            this.connected = true;
            this.log('FEAAS: Mount', this.tagName, this);
            this.dispatchEventIndirectly(new Event('feaasMount', { bubbles: true, composed: true }));
            this.getElements().map((element) => { var _a; return (_a = element.mount) === null || _a === void 0 ? void 0 : _a.call(element); });
            this.set();
        }
        catch (e) {
            this.onError(e);
        }
    }
    dispatchEventIndirectly(event) {
        this.dispatchEvent(event);
        const parent = this.getParent();
        if (parent && !parent.contains(this)) {
            Object.defineProperty(event, 'target', { value: this, writable: false });
            Object.defineProperty(event, 'composedPath', { value: () => [this], writable: false });
            parent.handleEvent(event);
        }
    }
    isJSONAttribute(attribute) {
        return false;
    }
    log(...args) {
        const format = args[0];
        if ((typeof location != 'undefined' && (location === null || location === void 0 ? void 0 : location.hostname.startsWith('components-'))) ||
            localStorage['Sitecore.Components.Debug'])
            console.log(format +
                ' ' +
                args
                    .slice(1)
                    .map((arg) => {
                    return arg && typeof arg == 'object' ? '%O' : '%s';
                })
                    .join(' '), ...args.slice(1));
    }
    /** Nothing special happens on unmount, except setting a flag */
    unmount() {
        if (!this.connected)
            return;
        this.log('FEAAS: Unmount', this);
        this.dispatchEventIndirectly(new Event('feaasUnmount', { bubbles: true, composed: true }));
        // If a component is react component, we need to re-render tree so that React can unmount it from VDOM
        // so observers can be removed
        if (this.connected && this.initialized && this.render) {
            this.update();
        }
        this.cancelRender();
        this.connected = false;
        // If a component is react component, we need to re-render tree so that React can unmount
        // it from VDOM, removing the observers
        if (this.initialized && this.render) {
            this.update();
        }
    }
    getParent(onlyFeaas = true) {
        for (var p = this; (p = p.parentElement || (p.parentNode instanceof ShadowRoot ? p.parentNode.host : null));) {
            if (!onlyFeaas || p.tagName.startsWith('FEAAS-'))
                return p;
        }
        // feaas context anywhere in the dom acts as a root element
        if (this.tagName != 'FEAAS-CONTEXT')
            return document.querySelector('feaas-context');
    }
    getElements(root = this.getRoot(), onlyFeaas = true) {
        return Array.from(root.querySelectorAll('*'))
            .map((el) => [
            !onlyFeaas || el.tagName.startsWith('FEAAS-') ? el : null,
            el.shadowRoot ? this.getElements(el.shadowRoot, onlyFeaas) : null
        ])
            .flat()
            .filter(Boolean);
    }
    /** Catch-all event handler that dispatches events to callback */
    handleEvent(event) {
        const target = event.composedPath()[0];
        switch (event.type) {
            case 'feaasMount':
                if (target != this)
                    this.nestedCallback(target);
                break;
            case 'feaasUnmount':
                if (target != this)
                    this.unnestedCallback(target);
                break;
        }
    }
    /** Act on children element being removed */
    unnestedCallback(target) {
        const index = this.descendants.indexOf(target);
        if (index == -1)
            return;
        this.log('FEAAS: Unnest', this, target);
        this.descendants.splice(index, 1);
        this.refs[target.getComponentName()] = null;
        if (target.refs.parent == this)
            target.refs.parent = null;
        if (target.refs.top == this) {
            target.refs.top = target.refs.parent;
        }
    }
    /** Act on children element being added */
    nestedCallback(target) {
        var _a, _b;
        const index = this.descendants.indexOf(target);
        if (index != -1)
            return;
        this.descendants.push(target);
        this.log('FEAAS: Nest', this, target);
        this.refs[target.getComponentName()] = target;
        target.refs.top = this;
        (_a = target.refs).parent || (_a.parent = this);
        if (target.render) {
            for (var p = target.refs.parent; p; p = p.refs.parent) {
                if (p.render) {
                    (_b = target.refs).parentReact || (_b.parentReact = p);
                    target.refs.topReact = p;
                }
            }
        }
    }
    getComponentName() {
        return this.tagName.replace('FEAAS-', '').toLowerCase();
    }
    /**
     * Check if lazy component is ready to be loaded. For example a component may stay unloaded unless certain attributes
     * are set
     */
    isReadyToLoad() {
        return this.payload === undefined && this.getAttribute('hidden') == null;
    }
    /** Generic error handler */
    onError(error, where = 'uncaught', handled = false) {
        const event = new CustomEvent('feaasError', { bubbles: true, composed: true, detail: error });
        this.dispatchEventIndirectly(event);
        this.whenLoaded.reject(error);
        if (!event.defaultPrevented && !handled) {
            this.whenRendered.reject(error);
            try {
                this.unmount();
            }
            catch (e) { }
            return true;
        }
        return false;
    }
    shouldUpdateOnLoad() {
        return true;
    }
    /** Load lazy component & render */
    async advance() {
        try {
            if (this.payload === undefined) {
                if (!this.isReadyToLoad())
                    return;
                this.payload = null;
                this.dispatchEventIndirectly(new Event('feaasLoad', { bubbles: true, composed: true }));
                const loaded = await this.load().catch((e) => {
                    this.payload = undefined;
                    throw e;
                });
                this.whenLoaded.resolve(loaded);
                // Allow component to handle the post-loading
                if (this.onLoad) {
                    return;
                }
            }
            else if (this.payload == null) {
                return;
            }
            this.flush();
            this.whenRendered.resolve(this);
        }
        catch (e) {
            this.onError(e);
        }
    }
    flush() {
        var _a, _b;
        if (!this.connected)
            return;
        const flushSync = (_b = (_a = this.payload) === null || _a === void 0 ? void 0 : _a.ReactDOM) === null || _b === void 0 ? void 0 : _b.flushSync;
        if (flushSync) {
            flushSync(() => this.update());
        }
        else {
            this.update();
        }
    }
    /** Invoke preloading logic that needs to finish before component can render */
    load() {
        return Promise.resolve(null);
    }
    /**
     * Component-specific logic that updates the DOM. Default render implementation assume react rendering, in that case
     * the component needs to provide React & ReactDOM references in its payload. Web component redefine its render to not
     * use react at all
     */
    update() {
        var _a, _b, _c;
        //this.log('FEAAS: React', this.tagName, this.payload)
        if (this.payload == null)
            return;
        if (!this.render)
            return;
        const { React, ReactDOM, ReactDOMClient } = this.payload || {};
        if (!React)
            throw new Error(`${this.tagName}: React is not present in payload`);
        if (!ReactDOM)
            throw new Error(`${this.tagName}: ReactDOM is not present in payload`);
        if (this.getAttribute('hydrate') == 'false' && this.firstElementChild)
            return;
        if (!this.refs.topReact && !this.forceUpdateReact) {
            this.reactRoot || (this.reactRoot = ReactDOMClient.createRoot(this.getReactRootElement()));
            this.reactRoot.render(this.getReactElement());
        }
        else if (this.forceUpdateReact && this.connected) {
            (_a = this.forceUpdateReact) === null || _a === void 0 ? void 0 : _a.call(this);
        }
        else {
            (_c = (_b = this.refs.topReact) === null || _b === void 0 ? void 0 : _b.forceUpdateReact) === null || _c === void 0 ? void 0 : _c.call(_b);
        }
    }
    invokeReactRendering() {
        const { React, ReactDOM } = this.payload || {};
        if (!this.connected)
            return null;
        const children = this.descendants
            .filter((r) => {
            return r.refs.parentReact == this && r.payload && r.connected;
        })
            .map((child, index) => {
            return this.getReactElement(child);
        });
        return this.render({ ...this.props, children }, this.payload);
    }
    getReactErrorBoundary(target = this, displayName = target.tagName) {
        if (this.reactErrorBoundary)
            return this.reactErrorBoundary;
        const { React, ReactDOM } = target.payload || {};
        return (this.reactErrorBoundary || (this.reactErrorBoundary = class FEAASErrorBoundary extends React.Component {
            constructor() {
                super(...arguments);
                this.state = {
                    error: null
                };
            }
            static getDerivedStateFromError(error) {
                return { error: error };
            }
            componentDidCatch(error, errorInfo) {
                console.error(`FEAAS: ${target.tagName} Error:`, error, errorInfo);
                target.onError(error, 'react');
                //this.setState({ error: error })
            }
            render() {
                if (this.state.error) {
                    // target.classList.add('feaas-error')
                    return;
                    //return <h1>There seems to be a problem.</h1>
                }
                //if (target.classList.contains('feaas-error')) target.classList.remove('feaas-error')
                return this.props.children;
            }
        }));
    }
    getReactElement(target = this, props) {
        const { React, ReactDOM } = target.payload || {};
        const ErrorBoundary = this.getReactErrorBoundary();
        const Wrapper = this.getReactWrapper(target);
        return (
        // @ts-ignore TS5 react types throws here
        React.createElement(ErrorBoundary, { key: target.tagName + '-' + target.getUID(), slot: target.getAttribute('slot') },
            React.createElement(Wrapper, null)));
    }
    getReactWrapper(target = this, displayName = target.tagName) {
        if (target.reactWrapper)
            return target.reactWrapper;
        const { React, ReactDOM } = target.payload || {};
        target.reactWrapper = (props) => {
            if (target.render) {
                const [value, forceUpdateReact] = React.useReducer((r) => r + 1, 0);
                target.forceUpdateReact = forceUpdateReact;
                return ReactDOM.createPortal(React.createElement(React.Fragment, null, target.invokeReactRendering()), target.getReactRootElement());
            }
            else {
                return target.update();
            }
        };
        Object.assign(target.reactWrapper, {
            key: target.tagName + '-' + target.getUID(),
            displayName: displayName
        });
        return target.reactWrapper;
    }
    getUID() {
        return (this.uid || (this.uid = String(Math.random())));
    }
    getShadowRoot() {
        if (!this.shadowRoot) {
            this.attachShadow({ mode: 'open' });
        }
        return this.shadowRoot;
    }
    getReactRootElement() {
        return this.useShadowRoot ? this.getShadowRoot() : this.getRoot();
    }
    /** Set props and return values on new next tick */
    set(overrides) {
        try {
            this.scheduleRender();
            this.overrides = {
                ...this.overrides,
                ...overrides
            };
            this.props = {
                ...this.getProps(),
                ...this.overrides
            };
            for (var property in this.props) {
                const isJSON = this.isJSONAttribute(property);
                const value = this.props[property];
                const valueAsString = isJSON ? JSON.stringify(value) : String(value);
                const defaultValue = this.defaultProps[property];
                const defaultValueAsString = isJSON ? JSON.stringify(defaultValue) : String(defaultValue);
                const attribute = property.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
                const oldValue = this.getAttribute(attribute);
                try {
                    var odlValueAsString = isJSON ? JSON.stringify(JSON.parse(oldValue)) : oldValue;
                }
                catch (e) {
                    var odlValueAsString = null;
                }
                if (value == null || valueAsString === defaultValueAsString) {
                    this.removeAttribute(attribute);
                }
                else if (typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean' || isJSON) {
                    if (odlValueAsString != valueAsString)
                        this.setAttribute(attribute, valueAsString);
                }
            }
        }
        catch (e) {
            this.whenRendered.reject(e);
            this.onError(e, 'set');
        }
        return this;
    }
    import(path) {
        return import(/* @vite-ignore */ /* webpackIgnore: true */ path);
    }
    scheduleRender() {
        if (this.nextRender == null) {
            this.whenRendered = this.whenRendered.restart();
        }
        this.cancelRender();
        this.nextRender = requestAnimationFrame(() => {
            this.nextRender = null;
            this.advance().catch((e) => { });
        });
    }
    cancelRender() {
        cancelAnimationFrame(this.nextRender);
    }
    formatURL(src, hostname) {
        if (typeof src == 'string' && src.match(/^\/[^\/]/)) {
            return hostname + src;
        }
        else {
            return src;
        }
    }
    getContextAttribute(name, element = this) {
        for (var p = this; (p = p.parentElement || (p.parentNode instanceof ShadowRoot ? p.parentNode.host : null));) {
            if (p.getAttribute(name) != null)
                return p.getAttribute(name);
        }
        return this.getAttribute(name);
    }
    static register(tagName, win) {
        if (win == null)
            win = typeof window != 'undefined' ? window : null;
        if (win && !win.customElements.get(tagName)) {
            win.customElements.define(tagName, this);
        }
    }
}
export { FEAASElement as Element };
export { WebComponent };
//# sourceMappingURL=FEAASElement.js.map