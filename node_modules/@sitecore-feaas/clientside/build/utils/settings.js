import { queryObject } from './data.js';
import { customizeDataSettings } from '@sitecore/byoc';
/**
 * Cleans the provided settings object by removing unnecessary properties that match the defaults that will be re-added
 * back through normalizations. This method is used for code generated for the user, neant to make it look neater.
 *
 * @param {any} settings  - The settings object to be cleaned.
 * @returns {Object} - The cleaned settings object.
 */
export function clean(settings) {
    const { params, method, headers, body, url } = DataSettings(settings);
    var cleanSettings = { url };
    var cleanHeaders = { ...headers };
    if (headers['Content-Type'] === 'application/json')
        delete cleanHeaders['Content-Type'];
    if (headers['Accept'] === 'application/json')
        delete cleanHeaders['Accept'];
    if (Object.keys(cleanHeaders).length > 0) {
        cleanSettings.headers = cleanHeaders;
    }
    if (method !== 'GET') {
        cleanSettings.method = method;
    }
    if (!(method === 'GET' || method === 'HEAD' || Object.keys(body).length === 0)) {
        cleanSettings.body = body;
    }
    if (Object.keys(params).length > 0) {
        cleanSettings = { ...cleanSettings, params };
    }
    return cleanSettings;
}
/**
 * Checks if the provided data is of type DataSettings by checking if all keys are recognized as settings keys.
 *
 * @param {any} data  - The data to be checked.
 * @returns {boolean} - True if the data is of type DataSettings, false otherwise.
 */
export const isDataSettings = (data) => {
    if (!data || typeof data.url != 'string')
        return false;
    for (var property in data) {
        if (property == 'body' ||
            property == 'params' ||
            property == 'headers' ||
            property == 'url' ||
            property === 'method' ||
            (property == 'jsonpath' && typeof data[property] == 'string')) {
            continue;
        }
        return false;
    }
    return true;
};
/**
 * Converts settings object into fetch function arguments.
 *
 * @param {any} settings  - The settings object.
 * @returns {Array} - An array containing URL and options objects as fetch function arguments.
 */
export function toFetchArguments(settings) {
    const { url, headers, params, method, body: payload } = DataSettings(settings);
    let body = undefined;
    const contentType = headers['Content-Type'];
    if (method != 'GET' && method != 'HEAD') {
        if (contentType === 'application/json')
            body = JSON.stringify(payload);
        if (contentType === 'multipart/form-data')
            body = Object.keys(payload).reduce((form, key) => {
                form.append(key, payload[key]);
                return form;
            }, new FormData());
        if (contentType === 'application/x-www-form-urlencoded')
            body = new URLSearchParams(payload);
    }
    const query = Object.keys(params).length ? `?${new URLSearchParams(params)}` : '';
    return [
        `${url}${query}`,
        {
            headers,
            body,
            method
        }
    ];
}
/**
 * Creates a DataSettings object based on the provided settings. These settings are used later to fetch data for the
 * component. It's essentially fetch options with url.
 *
 * @param {any} settings  - The settings object.
 * @returns {DataSettings} - The DataSettings object.
 */
export function DataSettings(settings) {
    const headers = {};
    for (const key in (settings === null || settings === void 0 ? void 0 : settings.headers) || {}) {
        if (settings.headers.hasOwnProperty(key)) {
            const headerCase = key.replace(/^[a-z]|\-[a-z]/g, (m) => m.toUpperCase());
            headers[headerCase] = settings.headers[key];
        }
    }
    if (!headers.Accept)
        headers['Accept'] = 'application/json';
    return {
        params: ((settings === null || settings === void 0 ? void 0 : settings.params) || {}),
        headers: headers,
        jsonpath: String((settings === null || settings === void 0 ? void 0 : settings.jsonpath) || '$'),
        method: ((settings === null || settings === void 0 ? void 0 : settings.method) || 'GET').toUpperCase(),
        body: ((settings === null || settings === void 0 ? void 0 : settings.body) || {}),
        url: String((settings === null || settings === void 0 ? void 0 : settings.url) || '')
    };
}
/**
 * Fetches data based on the provided settings. It is expected that reesponse is json (forced by Accept header)
 *
 * @param {DataSettings} settings  - The data settings.
 * @param {string} datasourceId  - The datasource id.
 * @returns {Promise<Data>} - A promise that resolves to the fetched data.
 */
const fetchDataSettings = async (settings, datasourceId) => {
    /**
     * Allow BYOC to intercept request and return custom settings
     */
    const datasourceSettingsGetter = customizeDataSettings(datasourceId, settings);
    if (datasourceSettingsGetter instanceof Promise) {
        return datasourceSettingsGetter;
    }
    // Apply custom settings
    let updatedSettings = settings;
    if (datasourceSettingsGetter) {
        updatedSettings = DataSettings(datasourceSettingsGetter);
    }
    try {
        const [url, options] = toFetchArguments(updatedSettings);
        const response = await DataSettings.fetchImplementation(url, {
            ...options,
            // next.js only allows lowercase method
            method: options.method.toLowerCase()
        });
        const json = await response.json();
        if (updatedSettings.jsonpath && updatedSettings.jsonpath != '$') {
            return queryObject(json, updatedSettings.jsonpath);
        }
        return json;
    }
    catch (e) {
        return {};
    }
};
/**
 * Fetches data based on the provided data options. Options is a union of different types, settngs, data or
 * datasource-id keyed settings/data. If the function doesnt find settings in the object, it returns it as is. It
 * supports mixing of static and fetched data. If multiple data settings are found, requests are made in parallel.
 *
 * @param {DataOptions} data  - The data options.
 * @returns {Promise<DataScopes>} - A promise that resolves to the fetched data.
 */
export async function fetchData(data) {
    if (!data)
        return data;
    if (isDataSettings(data))
        return fetchDataSettings(data);
    const keys = Object.keys(data);
    const allRequests = await Promise.all(keys
        .map((key) => {
        return isDataSettings(data[key]) ? fetchDataSettings(data[key], key) : null;
    })
        .filter(Boolean));
    return keys.reduce((obj, key) => ({
        ...obj,
        [key]: isDataSettings(data[key]) ? allRequests.shift() : data[key]
    }), {});
}
export function hasDataSettings(data) {
    if (!data)
        return false;
    return isDataSettings(data) || Object.values(data).some(isDataSettings);
}
DataSettings.clean = clean;
DataSettings.toFetchArguments = toFetchArguments;
DataSettings.fetchOne = fetchDataSettings;
DataSettings.fetch = fetchData;
DataSettings.isDataSettings = isDataSettings;
DataSettings.hasDataSettings = hasDataSettings;
DataSettings.fetchImplementation = (...args) => fetch(...args);
//# sourceMappingURL=settings.js.map