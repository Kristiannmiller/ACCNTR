import { ControlledPromise } from './utils/promise.js';
declare const phases: readonly ["initial", "check", "updated"];
export type ValidatableRequestPhase = (typeof phases)[number];
export type FetchCache = Record<string, FetchCacheRequest>;
export interface ValidatableRequest {
    url: Parameters<typeof fetch>[0];
    options?: Parameters<typeof fetch>[1];
    validator?: (resposne: Response, isCached: boolean) => boolean;
    callback?: (response: Response, status: ValidatableRequestPhase, isCached: boolean) => any;
    isCached?: boolean;
    response?: Response;
    cache?: FetchCache;
}
export type FetchCacheRequest = {
    phase: ValidatableRequestPhase;
    initial: ControlledPromise<Response>;
    check: ControlledPromise<Response>;
    updated: ControlledPromise<Response>;
    final: ControlledPromise<Response>;
};
export declare var fetchCache: Record<string, FetchCacheRequest>;
export declare function clearFetchCache(): void;
/**
 * Utility to cache-bust static files. It relies on reading Date header to detect cached response, so it requires CORS
 * settings to be set.
 *
 * It accepts validator function that determines if response is usable. If response was pulled from cache and is valid,
 * the optional callback function is fired right away. Then HEAD request is made bypassing the cache, to see if the
 * response has an newer Last-Modified header. In case it does and it passes validation, third request is fired that
 * actually fetches the new content and callback is invoked the second time.
 *
 * It works as promise, but also accepts callback to use cached blobs mid-flight and have access to headers. Any network
 * errors will not be caught. Function throws when unable to fetch valid response.
 */
export declare function fetchAndRevalidate(url: ValidatableRequest['url'], options?: ValidatableRequest['options'], validator?: ValidatableRequest['validator'], callback?: ValidatableRequest['callback'], cache?: FetchCache): Promise<Response>;
/**
 * Executes a fetch request optionally validating and handling the response. Using callback function it's possible to
 * observe successful response twice: Cached version first, and up-to-date later.
 *
 * @param {Object}                  request              - An object containing request parameters.
 * @param {string}                  request.url          - The URL to fetch.
 * @param {Object}                  request.options      - Fetch request options.
 * @param {Function}                [request.validator]  - Function to validate the response. Should return `false` if
 *                                                       validation fails.
 * @param {Function}                [request.callback]   - Function to execute after fetching. Receives the response,
 *                                                       phase, and cache status.
 * @param {Object}                  [request.cache]      - Cache object to store or retrieve cached data.
 * @param {ValidatableRequestPhase} [phase='initial']    - The phase of the request, defaults to 'initial'.
 * @returns {Promise<Object>} A promise that resolves to an object containing request details and the response.
 * @throws {Error} Throws an error if the fetch fails or if the response is not valid according to the validator.
 */
export declare function fetchWithCacheAwareness({ url, options, validator, callback, cache }: ValidatableRequest, phase?: ValidatableRequestPhase): Promise<{
    url: RequestInfo | URL;
    options: RequestInit;
    isCached: boolean;
    response: Response;
    validator: (resposne: Response, isCached: boolean) => boolean;
    callback: (response: Response, status: "initial" | "check" | "updated", isCached: boolean) => any;
    cache: FetchCache;
}>;
export declare function getFetchCache(url: Parameters<typeof fetch>[0], dontCreate?: boolean): FetchCacheRequest;
export declare class InvalidResponse extends Error {
}
/**
 * Validates cacheÂ of previousl fetch If the resource is cached and there is a newer version available, it will be
 * re-fetched.
 *
 * @param request  - The request object containing the URL, cache information, options, validator, and response of
 *                 initial request.
 * @returns A promise that resolves to the request object.
 */
export declare function fetchToValidateCache(request: ValidatableRequest & Required<Pick<ValidatableRequest, 'response'>>): Promise<ValidatableRequest & Required<Pick<ValidatableRequest, "response">>>;
export declare function fetchBypassingCache(request: ValidatableRequest): Promise<{
    url: RequestInfo | URL;
    options: RequestInit;
    isCached: boolean;
    response: Response;
    validator: (resposne: Response, isCached: boolean) => boolean;
    callback: (response: Response, status: "initial" | "check" | "updated", isCached: boolean) => any;
    cache: FetchCache;
}>;
export {};
//# sourceMappingURL=fetch.d.ts.map