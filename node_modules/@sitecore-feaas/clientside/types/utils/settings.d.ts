export type DataSourceId = string;
export type Data = Record<string, any> | any[];
export type DataScopes = Data | Record<DataSourceId, Data>;
export type DataSettings = ReturnType<typeof DataSettings>;
export type DataOptionsById = Record<DataSourceId, DataSettings | Data>;
export type DataOptions = Data | DataSettings | DataOptionsById;
/**
 * Cleans the provided settings object by removing unnecessary properties that match the defaults that will be re-added
 * back through normalizations. This method is used for code generated for the user, neant to make it look neater.
 *
 * @param {any} settings  - The settings object to be cleaned.
 * @returns {Object} - The cleaned settings object.
 */
export declare function clean(settings: any): Partial<{
    params: Record<string, any>;
    headers: Record<string, string>;
    jsonpath: string;
    method: "HEAD" | "GET" | "POST" | "OPTIONS" | "PUT" | "DELETE" | "UPDATE";
    body: Record<string, any>;
    url: string;
}>;
/**
 * Checks if the provided data is of type DataSettings by checking if all keys are recognized as settings keys.
 *
 * @param {any} data  - The data to be checked.
 * @returns {boolean} - True if the data is of type DataSettings, false otherwise.
 */
export declare const isDataSettings: (data: any) => data is {
    params: Record<string, any>;
    headers: Record<string, string>;
    jsonpath: string;
    method: "HEAD" | "GET" | "POST" | "OPTIONS" | "PUT" | "DELETE" | "UPDATE";
    body: Record<string, any>;
    url: string;
};
/**
 * Converts settings object into fetch function arguments.
 *
 * @param {any} settings  - The settings object.
 * @returns {Array} - An array containing URL and options objects as fetch function arguments.
 */
export declare function toFetchArguments(settings?: any): Parameters<typeof fetch>;
/**
 * Creates a DataSettings object based on the provided settings. These settings are used later to fetch data for the
 * component. It's essentially fetch options with url.
 *
 * @param {any} settings  - The settings object.
 * @returns {DataSettings} - The DataSettings object.
 */
export declare function DataSettings(settings: any): {
    params: Record<string, any>;
    headers: Record<string, string>;
    jsonpath: string;
    method: "HEAD" | "GET" | "POST" | "OPTIONS" | "PUT" | "DELETE" | "UPDATE";
    body: Record<string, any>;
    url: string;
};
export declare namespace DataSettings {
    var clean: typeof import("./settings.js").clean;
    var toFetchArguments: typeof import("./settings.js").toFetchArguments;
    var fetchOne: (settings: {
        params: Record<string, any>;
        headers: Record<string, string>;
        jsonpath: string;
        method: "HEAD" | "GET" | "POST" | "OPTIONS" | "PUT" | "DELETE" | "UPDATE";
        body: Record<string, any>;
        url: string;
    }, datasourceId?: string) => Promise<Data>;
    var fetch: typeof fetchData;
    var isDataSettings: (data: any) => data is {
        params: Record<string, any>;
        headers: Record<string, string>;
        jsonpath: string;
        method: "HEAD" | "GET" | "POST" | "OPTIONS" | "PUT" | "DELETE" | "UPDATE";
        body: Record<string, any>;
        url: string;
    };
    var hasDataSettings: typeof import("./settings.js").hasDataSettings;
    var fetchImplementation: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
/**
 * Fetches data based on the provided data options. Options is a union of different types, settngs, data or
 * datasource-id keyed settings/data. If the function doesnt find settings in the object, it returns it as is. It
 * supports mixing of static and fetched data. If multiple data settings are found, requests are made in parallel.
 *
 * @param {DataOptions} data  - The data options.
 * @returns {Promise<DataScopes>} - A promise that resolves to the fetched data.
 */
export declare function fetchData(data: DataOptions): Promise<DataScopes>;
export declare function hasDataSettings(data: DataOptions): boolean;
//# sourceMappingURL=settings.d.ts.map