import { afterAll, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest'
import { FEAASComponent } from '../src/components/FEAASComponent.js'
import { renderDOMContent } from '../src/dom/rendering.js'
import { clearFetchCache } from '../src/fetch.js'

const earliest = new Date(2000, 1, 1, 0, 0, 0)
const earlier = new Date(2000, 1, 2, 0, 0, 0)
const now = new Date(2000, 1, 2, 12, 0, 0)

describe('Components', () => {
  beforeAll(() => {
    // vi.useFakeTimers()
    vi.setSystemTime(now)
  })
  afterAll(() => {
    // vi.useRealTimers()
  })
  beforeEach(() => {
    document.open()
    document.write('<html><head></head><body></body></html>')
    document.close()
    clearFetchCache()
  })
  it('should load component using', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('CDN/components/L/C/V/R')) {
        return new Response('<p>FRESH</p>', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    // Fixme юhange to production component
    document.body.innerHTML =
      '<feaas-component fetch="template data" library="L" cdn="CDN" component="C" version="V" revision="R"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent

    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenCalledTimes(1)

    expect(component.innerHTML).toContain('<p>FRESH</p>')
  })

  describe('fetch control', () => {
    it('should not make requests when hydration is turned off, unless attribute changed after initial render', async () => {
      const spy = vi.spyOn(global, 'fetch')
      spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
        return new Response(url, {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      })
      // Fixme change to production component
      document.body.innerHTML =
        '<feaas-component fetch="" library="L" cdn="CDN" component="C" version="V" revision="R"></feaas-component>'

      const component = document.body.firstElementChild as FEAASComponent

      await expect(component.whenRendered).resolves.toEqual(component)
      expect(spy).toHaveBeenCalledTimes(0)

      component.setAttribute('library', 'Z')
      await expect(component.whenRendered).resolves.toEqual(component)
      expect(spy).toHaveBeenCalledTimes(1)

      expect(component.innerHTML).toBe('CDN/components/Z/C/V/R.html')
    })

    it('should not make requests when hydration is turned off, but should render template', async () => {
      const spy = vi.spyOn(global, 'fetch')

      // Fixme юhange to production component
      document.body.innerHTML =
        '<feaas-component fetch="" library="L" cdn="CDN" component="C" version="V" revision="R" template="abc"></feaas-component>'

      const component = document.body.firstElementChild as FEAASComponent

      await expect(component.whenRendered).resolves.toEqual(component)
      expect(spy).toHaveBeenCalledTimes(0)

      expect(component.innerHTML).toBe('abc')
    })

    it('should only make css request with fetch="stylesheet"', async () => {
      const spy = vi.spyOn(global, 'fetch')
      spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
        if (url.match('.css')) {
          return new Response('.a{}', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        }
      })
      // Fixme юhange to production component
      document.body.innerHTML =
        '<feaas-component fetch="stylesheet" library="L" cdn="CDN" component="C" version="V" revision="R">abc</feaas-component>'

      const component = document.body.firstElementChild as FEAASComponent

      await expect(component.whenRendered).resolves.toEqual(component)
      expect(spy).toHaveBeenCalledTimes(1)
      expect(component.innerHTML).toBe('abc')
      expect(document.head.querySelectorAll('style').length).toEqual(1)
    })

    it('should make html/css requests when fetch="stylesheet template"', async () => {
      const spy = vi.spyOn(global, 'fetch')
      spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
        if (url.match('CDN/components/L/C/V/R')) {
          return new Response('<p>FRESH</p>', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        }
        if (url.match('.css')) {
          return new Response('.a{}', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        }
      })
      document.body.innerHTML =
        '<feaas-component fetch="stylesheet template" library="L" cdn="CDN" component="C" version="V" revision="R"></feaas-component>'

      const component = document.body.firstElementChild as FEAASComponent

      await expect(component.whenRendered).resolves.toEqual(component)
      expect(spy).toHaveBeenCalledTimes(2)
      expect(component.innerHTML).toBe('<p>FRESH</p>')
      expect(document.head.querySelectorAll('style').length).toEqual(1)
    })
    it('should make data/css requests when fetch="stylesheet data"', async () => {
      const spy = vi.spyOn(global, 'fetch')
      spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
        if (url.match('my.json')) {
          return new Response('{"path": "value"}', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        }
        if (url.match('.css')) {
          return new Response('.a{}', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        }
      })

      document.body.innerHTML =
        '<feaas-component fetch="stylesheet data" data=\'{"source": {"url": "my.json"}}\' library="L" cdn="CDN" component="C" version="V" revision="R"><var data-path="source.path"></var></feaas-component>'

      const component = document.body.firstElementChild as FEAASComponent

      await expect(component.whenRendered).resolves.toEqual(component)
      expect(spy).toHaveBeenCalledTimes(2)
      expect(component.innerHTML).toBe('<var data-path="source.path">value</var>')
      expect(document.head.querySelectorAll('style').length).toEqual(1)
    })

    it('should fetch data even if fetch control doesnt allow it, once data attribute was updated', async () => {
      const spy = vi.spyOn(global, 'fetch')
      spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
        if (url.match('my.json')) {
          return new Response('{"path": "value"}', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        } else {
          throw new Error('Unknown fetch url' + url)
        }
      })

      document.body.innerHTML =
        '<feaas-component fetch="" data=\'{"source": {"path": "original"}}\' library="L" cdn="CDN" component="C" version="V" revision="R"><var data-path="source.path">original</var></feaas-component>'

      const component = document.body.firstElementChild as FEAASComponent

      await expect(component.whenRendered).resolves.toEqual(component)
      expect(spy).toHaveBeenCalledTimes(0)
      expect(component.innerHTML).toBe('<var data-path="source.path">original</var>')
      component.setAttribute('data', '{"source": {"url": "my.json"}}')
      await expect(component.whenRendered).resolves.toEqual(component)
      expect(spy).toHaveBeenCalledTimes(1)
      expect(component.innerHTML).toBe('<var data-path="source.path">value</var>')
    })
  })

  it('should load component using src attribute shorthand', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('http://a/components/b/c/d/1.html')) {
        return new Response('<p>FRESH</p>', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    document.body.innerHTML =
      '<feaas-component fetch="template data" src="http://a/components/b/c/d/1.html"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent

    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenCalledTimes(1)

    expect(component.outerHTML).toBe(
      `<feaas-component fetch="template data" src="http://a/components/b/c/d/1.html" cdn="http://a" library="b" component="c" version="d" revision="1" class="-feaas"><p>FRESH</p></feaas-component>`
    )
  })

  it('should load component with proper stylesheet revision', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('http://a/components/b/c/d/1.html')) {
        return new Response('<p>FRESH</p>', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      } else if (url.match('.css')) {
        // Validate
        return new Response(null, {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    document.body.innerHTML =
      '<feaas-component src="http://a/components/b/c/d/1.html"></feaas-component><feaas-component src="http://a/components/b/c/d/staged.html"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(document.head.querySelectorAll('style')[0].getAttribute('data-href')).toBe('http://a/styles/b/published.css')
    expect(document.head.querySelectorAll('style')[1].getAttribute('data-href')).toBe('http://a/styles/b/staged.css')
  })

  it('should validate stylesheet when included as link before rendering component', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('http://a/components/b/c/d/1.html')) {
        return new Response('<p>FRESH</p>', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      } else if (url.match('.css')) {
        return new Response('<p>FRESH</p>', {
          headers: {
            date: /*String(options?.method).toLowerCase() == 'head' ? */ now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    document.body.innerHTML =
      '<feaas-component src="http://a/components/b/c/d/1.html"></feaas-component><link rel="stylesheet" href="http://a/styles/b/published.css" />'

    const component = document.body.firstElementChild as FEAASComponent
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenCalledTimes(2)
    expect(document.head.querySelectorAll('style').length).toBe(0)
  })

  it('should validate and re-write stylesheet when included as link before rendering component', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('http://a/components/b/c/d/1.html')) {
        return new Response('<p>FRESH</p>', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      } else if (url.match('.css')) {
        if (!options?.cache) {
          // respond with cached css
          return new Response('CACHED', {
            headers: {
              date: earliest.toUTCString(),
              'last-modified': earliest.toUTCString()
            }
          })
        } else {
          // respond with up to date
          return new Response('CACHED', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earliest.toUTCString()
            }
          })
        }
      }
    })

    document.body.innerHTML =
      '<feaas-component src="http://a/components/b/c/d/1.html"></feaas-component><link rel="stylesheet" href="http://a/styles/b/published.css" />'

    const component = document.body.firstElementChild as FEAASComponent
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenCalledTimes(3)
    // render with stale stylesheet
    expect(document.head.querySelectorAll('style').length).toBe(0)
    await new Promise((r) => setTimeout(r, 50))
    expect(spy).toHaveBeenCalledTimes(3)
    expect(document.head.querySelectorAll('style').length).toBe(0)
  })

  it('should validate and re-write stylesheet when included as link before rendering component', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('http://a/components/b/c/d/1.html')) {
        return new Response('<p>FRESH</p>', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      } else if (url.match('.css')) {
        if (!options?.cache) {
          // respond with cached css
          return new Response('CACHED', {
            headers: {
              date: earliest.toUTCString(),
              'last-modified': earliest.toUTCString()
            }
          })
        } else {
          if (String(options?.method).toLowerCase() == 'head') await new Promise((r) => setTimeout(r, 50))
          // respond with up to date
          return new Response('<p>FRESH</p>', {
            headers: {
              date: now.toUTCString(),
              'last-modified': now.toUTCString()
            }
          })
        }
      }
    })

    document.body.innerHTML =
      '<feaas-component src="http://a/components/b/c/d/1.html"></feaas-component><link rel="stylesheet" href="http://a/styles/b/published.css" />'

    const component = document.body.firstElementChild as FEAASComponent
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenCalledTimes(3)
    // render with stale stylesheet
    expect(document.head.querySelectorAll('style').length).toBe(0)
    await new Promise((r) => setTimeout(r, 100))
    expect(spy).toHaveBeenCalledTimes(4)
    expect(document.head.querySelectorAll('style').length).toBe(1)
  })

  it('should revalidate cached component response', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('CDN/components/L/C/V/R') && options.method != 'HEAD') {
        // 1. Here's cached component
        return new Response('CACHED', {
          headers: {
            date: earlier.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      } else {
        // 2. Is my cached response up to date? Yes.
        return new Response(null, {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    document.body.innerHTML =
      '<feaas-component fetch="template data" library="L" cdn="CDN" component="C" version="V" revision="R"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent

    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenCalledTimes(2)

    expect(component.innerHTML).toContain('CACHED')
  })

  it('should reload component while using stale cache', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (options.method != 'HEAD' && options['cache'] != 'reload') {
        // Here's cached component
        return new Response('<p>YESTERDAY</p>', {
          headers: {
            date: earlier.toUTCString(),
            'last-modified': earliest.toUTCString()
          }
        })
      } else if (options.method == 'HEAD') {
        // Is my cached response up to date?
        return new Response(null, {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      } else {
        // Up to date version
        return new Response('<p>FRESH</p>', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    document.body.innerHTML =
      '<feaas-component fetch="template data" library="L" cdn="CDN" component="C" version="V" revision="R"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent
    // Renders cached version initially
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(component.innerHTML).toContain('<p>YESTERDAY</p>')
    expect(spy).toHaveBeenCalledTimes(2)

    // whenLoaded only fires when ensures that up-to-date version is loaded
    await expect(component.whenLoaded).resolves.toBeTruthy()
    expect(spy).toHaveBeenCalledTimes(3)
    expect(component.innerHTML).toContain('<p>FRESH</p>')
  })

  it('should re-fetch component when attributes change', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.match('CDN/components/L/C2/V/R')) {
        return new Response('C2', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      } else if (url.match('CDN/components/L/C1/V/R')) {
        return new Response('C1', {
          headers: {
            date: now.toUTCString(),
            'last-modified': earlier.toUTCString()
          }
        })
      }
    })

    document.body.innerHTML =
      '<feaas-component fetch="template data" library="L" cdn="CDN" component="C1" version="V" revision="R"></feaas-component>'

    const component = document.body.firstElementChild as FEAASComponent
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenNthCalledWith(1, 'CDN/components/L/C1/V/R.html', undefined)
    expect(spy).toHaveBeenCalledTimes(1)
    expect(component.innerHTML).toContain('C1')
    await expect(component.whenLoaded).resolves.toEqual('C1')

    component.setAttribute('component', 'C2')
    await expect(component.whenRendered).resolves.toEqual(component)
    expect(spy).toHaveBeenNthCalledWith(2, 'CDN/components/L/C2/V/R.html', undefined)
    expect(spy).toHaveBeenCalledTimes(2)
    expect(component.innerHTML).toContain('C2')
  })
  it('should wait for stylesheet to load', async () => {
    const spy = vi.spyOn(global, 'fetch')
    spy.mockImplementation(async (url: string, options: Parameters<typeof fetch>[1] = {}) => {
      if (url.includes('.css')) {
        if (url.match('/styles/L/published.css') && options?.method != 'HEAD' && options?.['cache'] != 'reload') {
          // Serve from cache
          await new Promise((resolve) => setTimeout(resolve, 100))
          return new Response('YESTERDAY {}', {
            headers: {
              date: earlier.toUTCString(),
              'last-modified': earliest.toUTCString()
            }
          })
        } else if (url.match('/styles/L/published.css') && options?.method == 'HEAD') {
          // Validate
          return new Response(null, {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        } else {
          await new Promise((resolve) => setTimeout(resolve, 200))
          return new Response('FRESH {}', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        }
      } else {
        if (options.method != 'HEAD' && options['cache'] != 'reload') {
          // Here's cached component
          return new Response('<p>YESTERDAY</p>', {
            headers: {
              date: earlier.toUTCString(),
              'last-modified': earliest.toUTCString()
            }
          })
        } else if (options.method == 'GET' && options['cache'] == 'reload') {
          // Is my cached response up to date?
          return new Response(null, {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        } else {
          //  Latest
          await new Promise((resolve) => setTimeout(resolve, 100))
          return new Response('<p>FRESH</p>', {
            headers: {
              date: now.toUTCString(),
              'last-modified': earlier.toUTCString()
            }
          })
        }
      }
    })

    document.body.innerHTML = '<feaas-component src="L/C"></feaas-component>'
    const component = document.body.firstElementChild as FEAASComponent
    expect(document.head.querySelector('style')).toBeNull()
    await new Promise((resolve) => setTimeout(resolve, 50))
    expect(document.head.querySelector('style')).toBeNull()
    expect(component.innerHTML).toEqual('')
    // Component will rendered with stale cached stylesheet
    await expect(component.whenRendered).resolves.toEqual(component)
    const stylesheet = document.head.querySelector('style') as HTMLStyleElement
    expect(stylesheet.innerHTML).toEqual('YESTERDAY {}')
    expect(component.innerHTML).toEqual('<p>YESTERDAY</p>')
    // Component will update itself with stale cached stylesheet
    await expect(component.whenLoaded).resolves.toEqual('<p>FRESH</p>')
    expect(stylesheet.innerHTML).toEqual('YESTERDAY {}')
    expect(component.innerHTML).toEqual('<p>FRESH</p>')
    await new Promise((resolve) => setTimeout(resolve, 200))
    // Stylesheet will update later
    expect(stylesheet.innerHTML).toEqual('FRESH {}')
  })

  it('render without data', () => {
    const component = new FEAASComponent()
    const div = document.createElement('div')
    div.appendChild(component)
    document.body.appendChild(div)
    renderDOMContent(component, `<section class="-theme--abc test"></section><section class="-theme--cde"></section>`)
    expect(div.innerHTML).toEqual(
      `<feaas-component class="-feaas"><section class="-theme--abc test"></section><section class="-theme--cde"></section></feaas-component>`
    )
    component.className = '-theme--override test2'
    renderDOMContent(component, `<section class="-theme--abc test"></section><section class="-theme--cde"></section>`)
    expect(div.innerHTML).toEqual(
      `<feaas-component class="-theme--override test2 -feaas"><section class="test"></section><section class=""></section></feaas-component>`
    )
  })
})
