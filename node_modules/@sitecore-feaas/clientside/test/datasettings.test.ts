import { vi, describe, it, expect } from 'vitest'
import { DataSettings } from '../src/utils/settings.js'
import * as BYOC from '@sitecore/byoc'

describe('DataSettings', () => {
  describe('.clean', () => {
    it('should clean', () => {
      expect(
        DataSettings.clean({
          url: 'http://url',
          method: 'post',
          params: { first: '1' },
          headers: { 'Content-type': 'multipart/form-data' },
          body: { key: 'value' }
        })
      ).to.eql({
        url: 'http://url',
        method: 'POST',
        params: { first: '1' },
        headers: { 'Content-Type': 'multipart/form-data' },
        body: { key: 'value' }
      })
      expect(DataSettings.clean({})).to.eql({ url: '' })
      expect(
        DataSettings.clean({
          headers: {
            accept: 'a-z'
          }
        })
      ).to.eql({
        url: '',
        headers: {
          Accept: 'a-z'
        }
      })
    })
  })
  describe('.toFetchArguments', () => {
    it('with no settings', () => {
      const fetchArgs = DataSettings.toFetchArguments()

      expect(fetchArgs).toEqual([
        '',
        {
          body: undefined,
          headers: { Accept: 'application/json' },
          method: 'GET'
        }
      ])
    })

    it('with url, params and post', () => {
      const fetchArgs = DataSettings.toFetchArguments({ url: 'http://url', method: 'post', params: { first: '1' } })

      expect(fetchArgs).toEqual([
        'http://url?first=1',
        { method: 'POST', body: undefined, headers: { Accept: 'application/json' } }
      ])
    })

    it('with url, params and post, body and headers application/json', () => {
      const fetchArgs = DataSettings.toFetchArguments({
        url: 'http://url',
        method: 'Post',
        params: { first: '1' },
        headers: { 'content-type': 'application/json', accept: 'abc' },
        body: { key: 'value' }
      })

      expect(fetchArgs).toEqual([
        'http://url?first=1',
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Accept: 'abc' },
          body: '{"key":"value"}'
        }
      ])
    })

    it('with url, params and post, body and headers multipart-form-data', () => {
      const fetchArgs = DataSettings.toFetchArguments({
        url: 'http://url',
        method: 'post',
        params: { first: '1' },
        headers: { 'Content-type': 'multipart/form-data' },
        body: { key: 'value' }
      })

      const form = new FormData()

      form.append('key', 'value')

      expect(fetchArgs).toEqual([
        'http://url?first=1',
        {
          method: 'POST',
          headers: { Accept: 'application/json', 'Content-Type': 'multipart/form-data' },
          body: form
        }
      ])
    })

    it('with url, params and post, body and headers url params', () => {
      const fetchArgs = DataSettings.toFetchArguments({
        url: 'http://url',
        method: 'post',
        params: { first: '1', second: '2' },
        headers: { 'Content-type': 'application/x-www-form-urlencoded' },
        body: { key: 'value' }
      })

      expect(fetchArgs).toEqual([
        'http://url?first=1&second=2',
        {
          method: 'POST',
          headers: { Accept: 'application/json', 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({ key: 'value' })
        }
      ])
    })
  })
  describe('.isDataSettings', () => {
    it('should return true if data has all the required properties', () => {
      const data = {
        url: 'https://example.com',
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      }

      expect(DataSettings.isDataSettings(data)).toBe(true)
    })

    it('should return false if data does not have the "url" property', () => {
      const data = {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      }

      expect(DataSettings.isDataSettings(data)).toBe(false)
    })

    it('should return false if data has an additional property apart from the allowed ones', () => {
      const data = {
        url: 'https://example.com',
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
        invalidProperty: 'invalid'
      }

      expect(DataSettings.isDataSettings(data)).toBe(false)
    })

    it('should return false if "jsonpath" property is not a string', () => {
      const data = {
        url: 'https://example.com',
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
        jsonpath: { invalid: 'value' }
      }

      expect(DataSettings.isDataSettings(data)).toBe(false)
    })
  })
  describe('.hasDataSettings', () => {
    it('should return false if data is falsy', () => {
      expect(DataSettings.hasDataSettings(null)).toBe(false)
      expect(DataSettings.hasDataSettings(undefined)).toBe(false)
      expect(DataSettings.hasDataSettings({ test: null })).toBe(false)
      expect(DataSettings.hasDataSettings({ test: undefined })).toBe(false)
    })
    it('should return true for simple case', () => {
      expect(DataSettings.hasDataSettings({ test: { url: 'a' } })).toBe(true)
      expect(DataSettings.hasDataSettings({ url: 'a' })).toBe(true)
    })

    it('should return true if data has a valid DataSettings object', () => {
      const data = {
        url: 'https://example.com',
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      }

      expect(DataSettings.hasDataSettings(data)).toBe(true)
      expect(DataSettings.hasDataSettings({ a: data })).toBe(true)
    })

    it('should return true if any property in data is a valid DataSettings object', () => {
      const data = {
        url: 'https://example.com',
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
        nestedData: {
          url: 'https://example.com/nested',
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        }
      }

      expect(DataSettings.hasDataSettings(data)).toBe(true)
    })

    it('should return false if all properties in data are invalid', () => {
      const data = {
        property1: 'value1',
        property2: { invalid: 'object' },
        property3: false
      }

      expect(DataSettings.hasDataSettings(data)).toBe(false)
    })

    // Add more test cases to cover other scenarios
  })
  describe('.fetch', () => {
    it('fetches when passed data object', async () => {
      const result = await DataSettings.fetch({ hello: 'world' })

      expect(result).toEqual({ hello: 'world' })
    })

    it('fetches when passed settings object', async () => {
      const spy = vi.spyOn(global, 'fetch')
      spy.mockImplementation(
        async (url: string, options?: Parameters<typeof fetch>[1]) =>
          new Response(JSON.stringify({ data: 'My data' }), {})
      )

      const result = await DataSettings.fetch({ jsonpath: '$', url: 'http://my-url' })

      expect(result).toEqual({ data: 'My data' })

      expect(spy).toHaveBeenCalledOnce()
    })

    it('fetches when passed mapping object', async () => {
      const spy = vi.spyOn(global, 'fetch')
      spy.mockImplementation(async (url: string, options?: Parameters<typeof fetch>[1]) => {
        if (url === 'http://my-url1') return new Response(JSON.stringify({ data: 'My data1' }), {})
        if (url === 'http://my-url2') return new Response(JSON.stringify({ data: 'My data2' }), {})
        throw new Error('Fetch failed')
      })

      const inputData = {
        datasourceId1: { jsonpath: '$', url: 'http://my-url1' },
        datasourceId2: { data: 'This is plain data' },
        datasourceId3: { jsonpath: '$', url: 'http://my-url2' },
        datasourceId4: { jsonpath: '$', url: 'http://bad-url' }
      }

      const result = await DataSettings.fetch(inputData)

      expect(result).to.have.property('datasourceId1')
      expect((result as Record<keyof typeof inputData, any>).datasourceId1).toEqual({ data: 'My data1' })

      expect(result).to.have.property('datasourceId2')
      expect((result as Record<keyof typeof inputData, any>).datasourceId2).toEqual({ data: 'This is plain data' })

      expect(result).to.have.property('datasourceId3')
      expect((result as Record<keyof typeof inputData, any>).datasourceId3).toEqual({ data: 'My data2' })

      expect(result).to.have.property('datasourceId4')
      expect((result as Record<keyof typeof inputData, any>).datasourceId4).toEqual({})

      expect(spy).toHaveBeenCalledTimes(3)
    })

    it('should serialize body', async () => {
      const spy = vi.spyOn(global, 'fetch')
      spy.mockImplementation(async (url: string, options?: Parameters<typeof fetch>[1]) => {
        return new Response(JSON.stringify(options), {})
      })

      const inputData = {
        datasourceId1: {
          url: 'http://my-url1',
          headers: { 'content-type': 'application/json' },
          body: { a: 1 },
          method: 'put'
        },
        datasourceId2: {
          url: 'http://my-url2',
          headers: { 'content-type': 'multipart/form-data' },
          body: { a: 1 },
          method: 'post'
        },
        datasourceId3: {
          url: 'http://my-url3',
          headers: { 'Content-type': 'application/x-www-form-urlencoded' },
          body: { a: 1 },
          method: 'patch'
        },
        datasourceId4: {
          url: 'http://my-url4',
          body: { a: 1 }
        }
      }

      const result = await DataSettings.fetch(inputData)

      expect(spy).toHaveBeenNthCalledWith(1, 'http://my-url1', {
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        body: '{"a":1}',
        method: 'put'
      })
      expect(spy).toHaveBeenNthCalledWith(2, 'http://my-url2', {
        headers: {
          Accept: 'application/json',
          'Content-Type': 'multipart/form-data'
        },
        body: (() => {
          const f = new FormData()
          f.append('a', '1')
          return f
        })(),
        method: 'post'
      })
      expect(spy).toHaveBeenNthCalledWith(3, 'http://my-url3', {
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: (() => {
          const f = new URLSearchParams()
          f.append('a', '1')
          return f
        })(),
        method: 'patch'
      })
      expect(spy).toHaveBeenNthCalledWith(4, 'http://my-url4', {
        body: undefined,
        headers: {
          Accept: 'application/json'
        },
        method: 'get'
      })
    })
  })
  describe('.fetch with BYOD', () => {

    it('should fetch with the custom settings', async () => {
      const customSettings = { url: 'http://customizedurl' }

      BYOC.registerDatasource(() => customSettings, {
        id: 'id',
        schema: {
          type: 'object',
          properties: {
            url: { type: 'string' }
          },
          required: ['url']
        }
      })

      const dataSettingsFetchSpy = vi.spyOn(global, 'fetch').mockReturnValue(Promise.resolve(new Response()))

      const initialSettings = { id: { url: 'http://url2' } }
      DataSettings.fetch(initialSettings)

      const options = {
        headers: { Accept: 'application/json' },
        method: 'get'
      }
      expect(dataSettingsFetchSpy).toHaveBeenCalledWith(customSettings.url, options)
    })
  })
})
