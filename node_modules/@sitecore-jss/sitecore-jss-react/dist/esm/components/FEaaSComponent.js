var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import React from 'react';
import * as FEAAS from '@sitecore-feaas/clientside/react';
import { LayoutServicePageState } from '@sitecore-jss/sitecore-jss/layout';
import { getDataFromFields } from '../utils';
export const FEAAS_COMPONENT_RENDERING_NAME = 'FEaaSComponent';
/**
 * @param {FEaaSComponentProps} props component props
 */
export const FEaaSComponent = (props) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const computedRevision = ((_a = props.params) === null || _a === void 0 ? void 0 : _a.ComponentRevision) || props.revisionFallback;
    if (!props.template &&
        (!props.params ||
            !props.params.LibraryId ||
            !props.params.ComponentId ||
            !props.params.ComponentVersion ||
            !props.params.ComponentHostName ||
            !computedRevision)) {
        // Missing FEaaS component required props
        return null;
    }
    // combine fetchedData from server with datasource data (if present)
    const data = Object.assign(Object.assign({}, props.fetchedData), { _: getDataFromFields((_b = props.fields) !== null && _b !== void 0 ? _b : {}) });
    // FEaaS control would still be hydrated by client
    // we pass all the props as a workaround to avoid hydration error, until we convert all JSS components to server side
    // this also allows component to fall back to full client-side rendering when template or src is empty
    // FEAAS should not fetch anything, since JSS does the fetching - so we pass empty array into fetch param
    return (React.createElement(FEAAS.Component, { data: data, template: props.template, cdn: (_c = props.params) === null || _c === void 0 ? void 0 : _c.ComponentHostName, library: (_d = props.params) === null || _d === void 0 ? void 0 : _d.LibraryId, version: (_e = props.params) === null || _e === void 0 ? void 0 : _e.ComponentVersion, component: (_f = props.params) === null || _f === void 0 ? void 0 : _f.ComponentId, instance: (_g = props.params) === null || _g === void 0 ? void 0 : _g.ComponentInstanceId, revision: computedRevision, fetch: [] }));
};
/**
 * Fetches server component props required for server rendering, based on rendering params.
 * Component endpoint will either be retrieved from params or from endpointOverride
 * @param {FEaaSComponentParams} params component params
 * @param {LayoutServicePageState} [pageState] page state to determine which component variant to use
 * @param {string} [endpointOverride] optional override for component endpoint
 */
export function fetchFEaaSComponentServerProps(params, pageState, endpointOverride) {
    return __awaiter(this, void 0, void 0, function* () {
        const revisionFallback = pageState && pageState !== LayoutServicePageState.Normal ? 'staged' : 'published';
        const src = endpointOverride || composeComponentEndpoint(params, revisionFallback);
        let template = '';
        let fetchedData = {};
        const fetchDataOptions = params.ComponentDataOverride
            ? JSON.parse(params.ComponentDataOverride)
            : {};
        try {
            template = yield fetchComponentTemplate(src, params, revisionFallback);
            fetchedData = yield fetchData(fetchDataOptions);
        }
        catch (e) {
            console.error(e);
        }
        return {
            fetchedData,
            revisionFallback,
            template,
        };
    });
}
/**
 * @param {string} src component endpoint
 * @param {FEaaSComponentParams} params rendering parameters for FEAAS component
 * @param {RevisionType} revisionFallback fallback revision to fetch if revision is absent in params
 */
function fetchComponentTemplate(src, params, revisionFallback) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { template } = yield FEAAS.fetchComponent(src);
            return template;
        }
        catch (error) {
            console.error(`Fetch FEAAS component from ${src} failed. Ensure the component revision "${params.ComponentRevision ||
                revisionFallback}" is present`);
            throw error;
        }
    });
}
/**
 * Fetches component data based on the provided data options.
 * This function asynchronously fetches data using the FEAAS.DataSettings.fetch method.
 *
 * @param {FEAAS.DataOptions} dataOptions - Options to customize data fetching.
 * @returns {Promise<FEAAS.DataScopes>} A promise that resolves with the fetched data,
 * or rejects with an error if data fetching encounters an issue.
 * @throws {Error} If an error occurs during data fetching, it is propagated as an error.
 */
function fetchData(dataOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const fetchedData = yield FEAAS.DataSettings.fetch(dataOptions || {});
            return fetchedData;
        }
        catch (error) {
            console.error('Fetch FEAAS component data settings failed');
            throw error;
        }
    });
}
/**
 * Build component endpoint URL from component's params
 * @param {FEaaSComponentParams} params rendering parameters for FEAAS component
 * @param {RevisionType} revisionFallback fallback revision to fetch if revision is absent in params
 * @returns component endpoint URL
 */
export const composeComponentEndpoint = (params, revisionFallback) => {
    const revision = params.ComponentRevision || revisionFallback;
    const hostname = params.ComponentHostName.startsWith('https://')
        ? params.ComponentHostName
        : `https://${params.ComponentHostName}`;
    return `${hostname}/components/${params.LibraryId}/${params.ComponentId}/${params.ComponentVersion}/${revision}`;
};
