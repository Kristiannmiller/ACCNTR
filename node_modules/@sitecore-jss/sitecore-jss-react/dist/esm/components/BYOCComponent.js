var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import React from 'react';
import { getDataFromFields } from '../utils';
import { MissingComponent } from './MissingComponent';
import * as FEAAS from '@sitecore-feaas/clientside/react';
export const BYOC_COMPONENT_RENDERING_NAME = 'BYOCComponent';
const DefaultErrorComponent = (props) => {
    var _a;
    return (React.createElement("div", null,
        "A rendering error occurred: ", (_a = props.error) === null || _a === void 0 ? void 0 :
        _a.message,
        "."));
};
/**
 * BYOCComponent facilitate the rendering of external components. It manages potential errors,
 * missing components, and customization of error messages or alternative rendering components.
 * @param {ByocComponentProps} props component props
 * @returns dynamicly rendered component or Missing Component error frame
 */
export class BYOCComponent extends React.Component {
    constructor(props) {
        super(props);
        this.state = {};
    }
    static getDerivedStateFromError(error) {
        // Update state so the next render will show the fallback UI.
        return { error: error };
    }
    componentDidCatch(error) {
        this.setState({ error });
    }
    render() {
        var _a, _b, _c;
        const props = this.props;
        if (this.state.error) {
            return this.props.errorComponent ? (React.createElement(this.props.errorComponent, { error: this.state.error })) : (React.createElement(DefaultErrorComponent, { error: this.state.error }));
        }
        const { ComponentName: componentName } = props.params || {};
        if (!componentName) {
            const noNameProps = {
                errorOverride: 'BYOC: The ComponentName for this rendering is missing',
            };
            return props.missingComponentComponent ? (React.createElement(this.props.missingComponentComponent, Object.assign({}, noNameProps))) : (React.createElement(MissingComponent, Object.assign({}, noNameProps)));
        }
        const unRegisteredComponentProps = {
            rendering: {
                componentName: componentName,
            },
            errorOverride: 'BYOC: This component was not registered.',
        };
        const fallbackComponent = this.props.missingComponentComponent ? (React.createElement(this.props.missingComponentComponent, Object.assign({}, unRegisteredComponentProps))) : (React.createElement(MissingComponent, Object.assign({}, unRegisteredComponentProps)));
        const ErrorComponent = this.props.errorComponent;
        let componentProps = {};
        if ((_a = props.params) === null || _a === void 0 ? void 0 : _a.ComponentProps) {
            try {
                componentProps = (_b = JSON.parse(props.params.ComponentProps)) !== null && _b !== void 0 ? _b : {};
            }
            catch (e) {
                console.error(`Parsing props for ${componentName} component from rendering params failed. Error: ${e}`);
                return ErrorComponent ? (React.createElement(ErrorComponent, { error: e })) : (React.createElement(DefaultErrorComponent, { error: e }));
            }
        }
        // apply props from item datasource
        const dataSourcesData = Object.assign(Object.assign({}, props.fetchedData), { _: getDataFromFields((_c = props.fields) !== null && _c !== void 0 ? _c : {}) });
        // we render fallback on client to avoid problems with client-only components
        return (React.createElement(FEAAS.ExternalComponent, Object.assign({ componentName: componentName, clientFallback: fallbackComponent, datasources: dataSourcesData }, componentProps)));
    }
}
/**
 * Fetches server component props required for server rendering, based on rendering params.
 * @param {BYOCComponentParams} params component params
 */
export function fetchBYOCComponentServerProps(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const fetchDataOptions = params.ComponentDataOverride
            ? JSON.parse(params.ComponentDataOverride)
            : {};
        const fetchedData = yield FEAAS.DataSettings.fetch(fetchDataOptions || {});
        return {
            fetchedData,
        };
    });
}
