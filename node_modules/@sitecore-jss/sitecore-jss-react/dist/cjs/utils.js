"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDataFromFields = exports.getAttributesString = exports.addClassName = exports.convertAttributesToReactProps = exports.convertStyleAttribute = exports.convertKebabCasetoCamelCase = void 0;
const layout_1 = require("@sitecore-jss/sitecore-jss/layout");
const style_attr_1 = require("style-attr");
// https://stackoverflow.com/a/10426674/9324
const convertKebabCasetoCamelCase = (str) => str.replace(/^.|-./g, (letter, index) => index === 0 ? letter.toLowerCase() : letter.substr(1).toUpperCase());
exports.convertKebabCasetoCamelCase = convertKebabCasetoCamelCase;
/**
 * https://facebook.github.io/react/docs/dom-elements.html
 * We are only concerned with style at the moment, which needs to be converted from string to object to satisfy React.
 * We don't need to convert any other attributes (that we know of), because the placeholder renders them "as-is" by using the special "is" React prop.
 * For whatever reason though, the "style" prop is still validated as needing to be an object when using the "is" prop, which is why we need to convert from string to object.
 * @param {string} [style] style
 * @returns {Array} converted attributes
 */
const convertStyleAttribute = (style = '') => {
    // styleParse converts a style attribute string into an object format
    const parsedStyle = (0, style_attr_1.parse)(style, { preserveNumbers: true });
    return Object.keys(parsedStyle).reduce((initialResult, styleKey) => {
        const result = initialResult;
        const convertedKey = (0, exports.convertKebabCasetoCamelCase)(styleKey);
        result[convertedKey] = parsedStyle[styleKey];
        return result;
    }, {});
};
exports.convertStyleAttribute = convertStyleAttribute;
const convertAttributesToReactProps = (attributes) => {
    if (!attributes) {
        return [];
    }
    return Object.keys(attributes).reduce((initialResult, attrName) => {
        const result = initialResult;
        switch (attrName) {
            case 'class': {
                result.className = attributes.class;
                break;
            }
            case 'style': {
                result.style = (0, exports.convertStyleAttribute)(attributes.style);
                break;
            }
            default: {
                result[attrName] = attributes[attrName];
                break;
            }
        }
        return result;
    }, {});
};
exports.convertAttributesToReactProps = convertAttributesToReactProps;
/**
 * "class" property will be transformed into or appended to "className" instead.
 * @param {string} otherAttrs all other props included on the image component
 * @returns {void}
 */
const addClassName = (otherAttrs) => {
    if (otherAttrs.class) {
        // if any classes are defined properly already
        if (otherAttrs.className) {
            let className = otherAttrs.className;
            className += ` ${otherAttrs.class}`;
            otherAttrs.className = className;
        }
        else {
            otherAttrs.className = otherAttrs.class;
        }
        delete otherAttrs.class;
    }
};
exports.addClassName = addClassName;
/**
 * Converts the given tag attributes object to a string
 * @param {Object.<string, unknown>} attributes the attributes object
 * @returns {string} string representation of the attributes
 */
const getAttributesString = (attributes) => {
    const { className } = attributes, restAttributes = __rest(attributes, ["className"]);
    const attributesEntries = Object.entries(restAttributes).map(([key, value]) => {
        if (typeof value === 'object') {
            const valueString = JSON.stringify(value)
                .replace(/"|{|}/g, '')
                .replace(/,/g, ';');
            return `${key}="${valueString}"`;
        }
        return `${key}="${value}"`;
    });
    if (className) {
        attributesEntries.push(`class="${className}"`);
    }
    return attributesEntries.join(' ');
};
exports.getAttributesString = getAttributesString;
/**
 * Used in FEAAS and BYOC implementations to convert datasource item field values into component props
 * @param {ComponentFields} fields field collection from Sitecore
 * @returns JSON object that can be used as props
 */
const getDataFromFields = (fields) => {
    let data = {};
    data = Object.entries(fields).reduce((acc, [key]) => {
        acc[key] = (0, layout_1.getFieldValue)(fields, key);
        return acc;
    }, data);
    return data;
};
exports.getDataFromFields = getDataFromFields;
